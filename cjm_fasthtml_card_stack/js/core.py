"""Master composer for card stack JavaScript. Combines viewport height,"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/js/core.ipynb.

# %% auto #0
__all__ = ['global_callback_name', 'generate_card_stack_js']

# %% ../../nbs/js/core.ipynb #jc000003
from typing import Any, Optional, Tuple

from fasthtml.common import Script

from ..core.config import CardStackConfig
from ..core.html_ids import CardStackHtmlIds
from ..core.button_ids import CardStackButtonIds
from ..core.models import CardStackUrls, CardStackState
from cjm_fasthtml_card_stack.core.constants import (
    width_storage_key, scale_storage_key, card_count_storage_key,
    auto_count_storage_key,
    DEFAULT_CARD_WIDTH, DEFAULT_CARD_SCALE, DEFAULT_VISIBLE_COUNT,
)
from .viewport import generate_viewport_height_js
from .scroll import generate_scroll_nav_js
from .touch import generate_touch_nav_js
from .navigation import generate_page_nav_js

# %% ../../nbs/js/core.ipynb #jc000005
def _generate_width_mgmt_js(
    ids: CardStackHtmlIds,  # HTML IDs for this instance
    config: CardStackConfig,  # Config with slider bounds
    urls: CardStackUrls,  # URL bundle (save_width)
) -> str:  # JS code fragment for width management
    """Generate JS for width slider management."""
    storage_key = width_storage_key(config.prefix)
    return f"""
        // === Width Management ===
        const _WIDTH_KEY = '{storage_key}';
        let _saveWidthTimer = null;

        function _saveWidthToServer(val) {{
            if (!'{urls.save_width}') return;
            clearTimeout(_saveWidthTimer);
            _saveWidthTimer = setTimeout(function() {{
                htmx.ajax('POST', '{urls.save_width}', {{
                    swap: 'none', values: {{ card_width: val }}
                }});
            }}, 500);
        }}

        ns.updateWidth = function(value) {{
            const inner = document.getElementById('{ids.card_stack_inner}');
            if (!inner) return;
            inner.style.maxWidth = value + 'rem';
            try {{ localStorage.setItem(_WIDTH_KEY, value); }} catch (e) {{}}
            const slider = document.getElementById('{ids.width_slider}');
            if (slider && parseInt(slider.value) !== parseInt(value)) slider.value = value;
            _saveWidthToServer(value);
            if (ns.triggerAutoAdjust) ns.triggerAutoAdjust();
        }};

        ns.decreaseWidth = function() {{
            const slider = document.getElementById('{ids.width_slider}');
            const current = slider ? parseInt(slider.value) : {DEFAULT_CARD_WIDTH};
            ns.updateWidth(Math.max({config.card_width_min}, current - {config.card_width_step}));
        }};

        ns.increaseWidth = function() {{
            const slider = document.getElementById('{ids.width_slider}');
            const current = slider ? parseInt(slider.value) : {DEFAULT_CARD_WIDTH};
            ns.updateWidth(Math.min({config.card_width_max}, current + {config.card_width_step}));
        }};

        ns.applyWidth = function() {{
            const inner = document.getElementById('{ids.card_stack_inner}');
            if (!inner) return;
            let val = {DEFAULT_CARD_WIDTH};
            try {{ const s = localStorage.getItem(_WIDTH_KEY); if (s) val = parseInt(s); }} catch (e) {{}}
            inner.style.maxWidth = val + 'rem';
            const slider = document.getElementById('{ids.width_slider}');
            if (slider) slider.value = val;
        }};
    """

# %% ../../nbs/js/core.ipynb #jc000006
def _generate_scale_mgmt_js(
    ids: CardStackHtmlIds,  # HTML IDs for this instance
    config: CardStackConfig,  # Config with slider bounds
    urls: CardStackUrls,  # URL bundle (save_scale)
) -> str:  # JS code fragment for scale management
    """Generate JS for scale slider management."""
    storage_key = scale_storage_key(config.prefix)
    return f"""
        // === Scale Management ===
        const _SCALE_KEY = '{storage_key}';
        let _saveScaleTimer = null;

        function _saveScaleToServer(val) {{
            if (!'{urls.save_scale}') return;
            clearTimeout(_saveScaleTimer);
            _saveScaleTimer = setTimeout(function() {{
                htmx.ajax('POST', '{urls.save_scale}', {{
                    swap: 'none', values: {{ card_scale: val }}
                }});
            }}, 500);
        }}

        function _applyScaleCssProperty(val) {{
            const cs = document.getElementById('{ids.card_stack}');
            if (cs) cs.style.setProperty('--card-stack-scale', val);
        }}

        ns.updateScale = function(value) {{
            _applyScaleCssProperty(value);
            try {{ localStorage.setItem(_SCALE_KEY, value); }} catch (e) {{}}
            const slider = document.getElementById('{ids.scale_slider}');
            if (slider && parseInt(slider.value) !== parseInt(value)) slider.value = value;
            _saveScaleToServer(value);
            if (ns.triggerAutoAdjust) ns.triggerAutoAdjust();
        }};

        ns.decreaseScale = function() {{
            const slider = document.getElementById('{ids.scale_slider}');
            const current = slider ? parseInt(slider.value) : {DEFAULT_CARD_SCALE};
            ns.updateScale(Math.max({config.card_scale_min}, current - {config.card_scale_step}));
        }};

        ns.increaseScale = function() {{
            const slider = document.getElementById('{ids.scale_slider}');
            const current = slider ? parseInt(slider.value) : {DEFAULT_CARD_SCALE};
            ns.updateScale(Math.min({config.card_scale_max}, current + {config.card_scale_step}));
        }};

        ns.applyScale = function() {{
            let val = {DEFAULT_CARD_SCALE};
            try {{ const s = localStorage.getItem(_SCALE_KEY); if (s) val = parseInt(s); }} catch (e) {{}}
            _applyScaleCssProperty(val);
            const slider = document.getElementById('{ids.scale_slider}');
            if (slider) slider.value = val;
        }};
    """

# %% ../../nbs/js/core.ipynb #jc000007
def _generate_card_count_mgmt_js(
    ids: CardStackHtmlIds,  # HTML IDs for this instance
    config: CardStackConfig,  # Config with count options
    urls: CardStackUrls,  # URL bundle (update_viewport)
) -> str:  # JS code fragment for card count management
    """Generate JS for card count selector management."""
    storage_key = card_count_storage_key(config.prefix)
    auto_key = auto_count_storage_key(config.prefix)
    valid_counts = ', '.join(str(c) for c in config.visible_count_options)
    return f"""
        // === Card Count Management ===
        const _COUNT_KEY = '{storage_key}';
        const _AUTO_KEY = '{auto_key}';
        const _VALID_COUNTS = [{valid_counts}];

        function _isAutoMode() {{
            try {{ return localStorage.getItem(_AUTO_KEY) === 'true'; }} catch (e) {{ return false; }}
        }}

        function _getStoredCount() {{
            try {{
                const s = localStorage.getItem(_COUNT_KEY);
                if (s) {{ const c = parseInt(s); if (_VALID_COUNTS.includes(c)) return c; }}
            }} catch (e) {{}}
            return {DEFAULT_VISIBLE_COUNT};
        }}

        ns.updateCardCount = function(value) {{
            const count = parseInt(value);
            if (!_VALID_COUNTS.includes(count)) return;
            try {{ localStorage.setItem(_COUNT_KEY, count); }} catch (e) {{}}
            const cardStack = document.getElementById('{ids.card_stack}');
            if (cardStack) cardStack.dataset.visibleCount = count;
            if ('{urls.update_viewport}') {{
                htmx.ajax('POST', '{urls.update_viewport}', {{
                    target: '#' + '{ids.card_stack}',
                    swap: 'none',
                    values: {{ visible_count: count }}
                }});
            }}
        }};

        ns._autoUpdateCount = function(count) {{
            // Like updateCardCount but bypasses _VALID_COUNTS validation.
            // Used by auto-adjustment which can set any count.
            const c = Math.max(1, Math.round(count));
            const cardStack = document.getElementById('{ids.card_stack}');
            if (cardStack) cardStack.dataset.visibleCount = c;
            if ('{urls.update_viewport}') {{
                htmx.ajax('POST', '{urls.update_viewport}', {{
                    target: '#' + '{ids.card_stack}',
                    swap: 'none',
                    values: {{ visible_count: c }}
                }});
            }}
        }};

        ns.handleCountChange = function(value) {{
            // Entry point for dropdown onchange — handles both "auto" and numeric values.
            if (value === 'auto') {{
                try {{ localStorage.setItem(_AUTO_KEY, 'true'); }} catch (e) {{}}
                if (ns.triggerAutoAdjust) ns.triggerAutoAdjust();
            }} else {{
                try {{ localStorage.removeItem(_AUTO_KEY); }} catch (e) {{}}
                if (ns._cancelAutoGrowth) ns._cancelAutoGrowth();
                ns.updateCardCount(parseInt(value));
            }}
        }};

        function _syncCountDropdown() {{
            const sel = document.getElementById('{ids.card_count_select}');
            if (!sel) return;
            if (_isAutoMode()) {{
                if (sel.value !== 'auto') sel.value = 'auto';
            }} else {{
                const stored = _getStoredCount();
                if (parseInt(sel.value) !== stored) sel.value = stored;
            }}
        }}
    """

# %% ../../nbs/js/core.ipynb #c1jcaj0lnav
def _generate_auto_adjust_js(
    ids: CardStackHtmlIds,  # HTML IDs for this instance
    config: CardStackConfig,  # Config for auto mode check
    urls: CardStackUrls,  # URL bundle (update_viewport)
    focus_position: Optional[int] = None,  # Focus slot offset (None=center, -1=bottom, 0=top)
) -> str:  # JS code fragment for auto visible count adjustment
    """Generate JS for automatic visible count adjustment based on overflow detection."""
    js_focus_pos = "null" if focus_position is None else str(focus_position)
    return f"""
        // === Auto Visible Count Adjustment ===
        let _autoAdjusting = false;
        let _autoAdjustTimer = null;
        const _AUTO_FOCUS_POS = {js_focus_pos};
        const _AUTO_STEP = (_AUTO_FOCUS_POS === null) ? 2 : 1;

        // --- Growth validation state ---
        let _autoGrowing = false;
        let _autoReverting = false;
        let _preGrowthItemIds = null;
        let _preGrowthCount = 0;

        function _getAutoCurrentCount() {{
            const cs = document.getElementById('{ids.card_stack}');
            return cs ? parseInt(cs.dataset.visibleCount || '{DEFAULT_VISIBLE_COUNT}') : {DEFAULT_VISIBLE_COUNT};
        }}

        function _getAutoTotalItems() {{
            const cs = document.getElementById('{ids.card_stack}');
            return cs ? parseInt(cs.dataset.totalItems || '0') : 0;
        }}

        function _getAutoSectionOverflow() {{
            // Returns max overflow (px) across relevant sections.
            // Before section uses justify-end, so content overflows upward (out the top).
            // After section uses justify-start, so content overflows downward (out the bottom).
            const before = document.getElementById('{ids.viewport_section_before}');
            const after = document.getElementById('{ids.viewport_section_after}');
            let maxOverflow = 0;

            const checkBefore = (_AUTO_FOCUS_POS === null || _AUTO_FOCUS_POS > 0 || _AUTO_FOCUS_POS < 0);
            const checkAfter = (_AUTO_FOCUS_POS === null || _AUTO_FOCUS_POS >= 0);

            // Before section: check if first child extends above container top
            if (checkBefore && before && before.children.length > 0) {{
                const sRect = before.getBoundingClientRect();
                const firstChild = before.children[0];
                const childRect = firstChild.getBoundingClientRect();
                const o = sRect.top - childRect.top;  // positive if child above container
                if (o > maxOverflow) maxOverflow = o;
            }}

            // After section: check if last child extends below container bottom
            if (checkAfter && after && after.children.length > 0) {{
                const sRect = after.getBoundingClientRect();
                const lastChild = after.children[after.children.length - 1];
                const childRect = lastChild.getBoundingClientRect();
                const o = childRect.bottom - sRect.bottom;  // positive if child below container
                if (o > maxOverflow) maxOverflow = o;
            }}

            return maxOverflow;
        }}

        function _getAutoAvgCardHeight() {{
            // Average height of rendered viewport-slot elements.
            const cs = document.getElementById('{ids.card_stack}');
            if (!cs) return 100;
            const slots = cs.querySelectorAll('.viewport-slot');
            if (slots.length === 0) return 100;
            let total = 0;
            for (const s of slots) total += s.getBoundingClientRect().height;
            return total / slots.length;
        }}

        function _getAutoGapPx() {{
            // Read computed gap from the before section (or after).
            const section = document.getElementById('{ids.viewport_section_before}')
                         || document.getElementById('{ids.viewport_section_after}');
            if (!section) return 16;
            return parseFloat(getComputedStyle(section).gap) || 16;
        }}

        // --- Growth validation helpers ---

        function _snapshotItemIds() {{
            const cs = document.getElementById('{ids.card_stack}');
            if (!cs) return new Set();
            const slots = cs.querySelectorAll('.viewport-slot');
            const idSet = new Set();
            for (const s of slots) {{
                if (s.id) idSet.add(s.id);
            }}
            return idSet;
        }}

        function _hideNewItems() {{
            if (!_preGrowthItemIds) return;
            const cs = document.getElementById('{ids.card_stack}');
            if (!cs) return;
            const slots = cs.querySelectorAll('.viewport-slot');
            for (const s of slots) {{
                if (s.id && !_preGrowthItemIds.has(s.id)) {{
                    s.style.opacity = '0';
                }}
            }}
        }}

        function _revealNewItems() {{
            const cs = document.getElementById('{ids.card_stack}');
            if (!cs) return;
            const slots = cs.querySelectorAll('.viewport-slot');
            for (const s of slots) {{
                if (s.style.opacity === '0') {{
                    s.style.removeProperty('opacity');
                }}
            }}
        }}

        function _validateGrowth() {{
            const overflow = _getAutoSectionOverflow();
            if (overflow > 2) {{
                // Growth caused overflow — revert to pre-growth count and stop
                _autoGrowing = false;
                _autoReverting = true;
                _preGrowthItemIds = null;
                _autoAdjusting = true;
                ns._autoUpdateCount(_preGrowthCount);
            }} else {{
                // Growth fits — reveal the new items
                _revealNewItems();
                _autoGrowing = false;
                _preGrowthItemIds = null;
                // Continue to check if there's still room for more
                requestAnimationFrame(function() {{
                    ns._runAutoAdjust();
                }});
            }}
        }}

        ns._cancelAutoGrowth = function() {{
            if (_autoGrowing) {{
                _revealNewItems();
                _autoGrowing = false;
                _preGrowthItemIds = null;
                _preGrowthCount = 0;
            }}
            _autoReverting = false;
        }};

        ns._runAutoAdjust = function() {{
            if (!_isAutoMode() || _autoAdjusting) return;

            // If we just reverted from a failed growth, stop the loop
            if (_autoReverting) {{
                _autoReverting = false;
                return;
            }}

            // If in growth validation cycle, validate instead of normal adjust
            if (_autoGrowing) {{
                _validateGrowth();
                return;
            }}

            const currentCount = _getAutoCurrentCount();
            const totalItems = _getAutoTotalItems();
            if (totalItems === 0) return;

            const overflow = _getAutoSectionOverflow();
            const avgHeight = _getAutoAvgCardHeight();
            const gapPx = _getAutoGapPx();

            if (overflow > 2) {{
                // Overflow exists — remove enough cards to eliminate it
                const toRemove = Math.ceil(overflow / (avgHeight + gapPx));
                const adjusted = (_AUTO_FOCUS_POS === null)
                    ? Math.max(_AUTO_STEP, Math.ceil(toRemove / 2) * 2)
                    : Math.max(_AUTO_STEP, toRemove);
                const newCount = Math.max(1, currentCount - adjusted);
                if (newCount !== currentCount) {{
                    _autoAdjusting = true;
                    ns._autoUpdateCount(newCount);
                }}
            }} else {{
                // No overflow — try to add more cards incrementally
                if (currentCount >= totalItems) return;

                const newCount = Math.min(totalItems, currentCount + _AUTO_STEP);
                if (newCount > currentCount) {{
                    // Snapshot current state before growth
                    _preGrowthCount = currentCount;
                    _preGrowthItemIds = _snapshotItemIds();
                    _autoGrowing = true;
                    _autoAdjusting = true;
                    ns._autoUpdateCount(newCount);
                }}
            }}
        }};

        ns.triggerAutoAdjust = function() {{
            // Debounced entry point for external triggers (resize, width, scale).
            if (!_isAutoMode()) return;
            clearTimeout(_autoAdjustTimer);
            _autoReverting = false;
            _autoAdjustTimer = setTimeout(function() {{
                ns._runAutoAdjust();
            }}, 200);
        }};
    """

# %% ../../nbs/js/core.ipynb #jc000009
def _generate_coordinator_js(
    ids: CardStackHtmlIds,  # HTML IDs for this instance
    config: CardStackConfig,  # Config for prefix-unique listener guards
    focus_position: Optional[int] = None,  # Focus slot offset (None=center, -1=bottom, 0=top)
) -> str:  # JS code fragment for master coordinator
    """Generate JS for the master coordinator and HTMX listener."""
    guard_var = f"_csMasterListener_{config.prefix.replace('-', '_')}"
    js_focus_pos = "null" if focus_position is None else str(focus_position)
    return f"""
        // === Grid Template Management ===
        ns.applyGridTemplate = function() {{
            const inner = document.getElementById('{ids.card_stack_inner}');
            if (!inner) return;
            const focusPosRaw = {js_focus_pos};
            let tmpl;
            if (focusPosRaw === null) {{
                tmpl = '1fr auto 1fr';
            }} else if (focusPosRaw === 0) {{
                tmpl = 'auto 1fr';
            }} else if (focusPosRaw < 0) {{
                tmpl = '1fr auto';
            }} else {{
                tmpl = '1fr auto 1fr';
            }}
            inner.style.gridTemplateRows = tmpl;
        }};

        // === Master Coordinator ===
        ns.applyAllViewportSettings = function() {{
            requestAnimationFrame(function() {{
                if (ns.applyWidth) ns.applyWidth();
                if (ns.applyScale) ns.applyScale();
                if (ns.applyGridTemplate) ns.applyGridTemplate();
                if (ns.recalculateHeight) ns.recalculateHeight();

                const cs = document.getElementById('{ids.card_stack}');
                if (cs) {{
                    cs._scrollNavSetup = false;
                    if (ns._setupScrollNav) ns._setupScrollNav();
                    if (ns._setupTouchNav) ns._setupTouchNav();
                }}

                requestAnimationFrame(function() {{
                    const cs2 = document.getElementById('{ids.card_stack}');
                    if (cs2) cs2.style.opacity = '1';

                    // Continue auto-adjust loop if an adjustment is in flight
                    if (typeof _autoAdjusting !== 'undefined' && _autoAdjusting) {{
                        _autoAdjusting = false;
                        requestAnimationFrame(function() {{
                            if (ns._runAutoAdjust) ns._runAutoAdjust();
                        }});
                    }}
                }});
            }});
        }};

        // === HTMX Event Listeners ===
        if (!window.{guard_var}) {{
            window.{guard_var} = true;

            // afterSwap: hide new items before browser paints during growth validation
            document.body.addEventListener('htmx:afterSwap', function(evt) {{
                const target = evt.detail.target;
                if (!target) return;
                const cs = document.getElementById('{ids.card_stack}');
                const isCSSwap = (
                    target.id === '{ids.card_stack}' ||
                    target.id === '{ids.card_stack_inner}' ||
                    (cs && cs.contains(target))
                );
                if (isCSSwap && typeof _autoGrowing !== 'undefined' && _autoGrowing) {{
                    _hideNewItems();
                }}
            }});

            // afterSettle: sync state and apply viewport settings
            document.body.addEventListener('htmx:afterSettle', function(evt) {{
                const target = evt.detail.target;
                if (!target) return;
                const cs = document.getElementById('{ids.card_stack}');
                const isCSSwap = (
                    target.id === '{ids.card_stack}' ||
                    target.id === '{ids.card_stack_inner}' ||
                    (cs && cs.contains(target))
                );
                if (isCSSwap) {{
                    _syncCountDropdown();
                    ns.applyAllViewportSettings();
                }}
            }});
        }}

        // === Initialize ===
        requestAnimationFrame(function() {{
            _syncCountDropdown();
            setTimeout(function() {{
                ns.applyAllViewportSettings();
                // Trigger auto-adjust after initial layout settles
                if (ns.triggerAutoAdjust) ns.triggerAutoAdjust();
            }}, 50);
        }});
    """

# %% ../../nbs/js/core.ipynb #jhgisn5noqk
# Callback name constants — must match what create_card_stack_nav_actions uses
_GLOBAL_CALLBACKS = (
    "jumpPageUp",
    "jumpPageDown",
    "jumpToFirstItem",
    "jumpToLastItem",
    "decreaseWidth",
    "increaseWidth",
    "decreaseScale",
    "increaseScale",
)

def global_callback_name(
    prefix: str,  # Card stack instance prefix
    callback: str,  # Base callback name (e.g., "jumpPageUp")
) -> str:  # Global function name (e.g., "cs0_jumpPageUp")
    """Generate a prefix-unique global callback name for keyboard navigation."""
    return f"{prefix}_{callback}"

def _generate_global_callbacks_js(
    config: CardStackConfig,  # Config with prefix
) -> str:  # JS code fragment registering global wrappers
    """Register global wrappers for keyboard navigation system."""
    lines = ["        // === Global Keyboard Callbacks ==="]
    for cb in _GLOBAL_CALLBACKS:
        global_name = global_callback_name(config.prefix, cb)
        lines.append(f"        window['{global_name}'] = function() {{ if (ns.{cb}) ns.{cb}(); }};")
    return "\n".join(lines)

# %% ../../nbs/js/core.ipynb #jc000011
def generate_card_stack_js(
    ids: CardStackHtmlIds,  # HTML IDs for this instance
    button_ids: CardStackButtonIds,  # Button IDs for keyboard triggers
    config: CardStackConfig,  # Card stack configuration
    urls: CardStackUrls,  # URL bundle for routing
    container_id: str = "",  # Consumer's parent container ID (for height calc)
    extra_scripts: Tuple[str, ...] = (),  # Additional JS to include in the IIFE
    focus_position: Optional[int] = None,  # Focus slot offset (None=center, -1=bottom, 0=top)
) -> Any:  # Script element with all card stack JavaScript
    """Compose all card stack JS into a single namespaced IIFE."""
    prefix = config.prefix
    extra_js = "\n".join(extra_scripts)

    # Collect all fragments
    viewport_js = generate_viewport_height_js(ids, container_id)
    scroll_js = generate_scroll_nav_js(ids, button_ids, config.disable_scroll_in_modes)
    touch_js = generate_touch_nav_js(ids, button_ids, config.disable_scroll_in_modes)
    page_nav_js = generate_page_nav_js(button_ids)
    width_js = _generate_width_mgmt_js(ids, config, urls)
    scale_js = _generate_scale_mgmt_js(ids, config, urls)
    count_js = _generate_card_count_mgmt_js(ids, config, urls)
    auto_js = _generate_auto_adjust_js(ids, config, urls, focus_position) if config.auto_visible_count else ""
    global_cbs_js = _generate_global_callbacks_js(config)
    coordinator_js = _generate_coordinator_js(ids, config, focus_position)

    return Script(f"""(function() {{
        window.cardStacks = window.cardStacks || {{}};
        const ns = window.cardStacks['{prefix}'] = {{}};

        {viewport_js}
        {scroll_js}
        {touch_js}
        {page_nav_js}
        {width_js}
        {scale_js}
        {count_js}
        {auto_js}
        {global_cbs_js}
        {coordinator_js}
        {extra_js}
    }})();""")
