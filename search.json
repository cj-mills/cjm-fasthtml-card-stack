[
  {
    "objectID": "keyboard/actions.html",
    "href": "keyboard/actions.html",
    "title": "Actions",
    "section": "",
    "text": "Creates a FocusZone configured for the card stack viewport. Uses ScrollOnly navigation since all navigation is handled via HTMX button triggers, not the keyboard library’s built-in item navigation.\n\nsource\n\n\n\ndef create_card_stack_focus_zone(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    on_focus_change:Optional=None, # JS callback name on focus change\n    hidden_input_prefix:Optional=None, # Prefix for keyboard nav hidden inputs\n    data_attributes:Tuple=(), # Data attributes to track on focused items\n)-&gt;FocusZone: # Configured focus zone for the card stack\n\nCreate a focus zone for a card stack viewport.\n\n# Test create_card_stack_focus_zone\nids = CardStackHtmlIds(prefix=\"cs0\")\nzone = create_card_stack_focus_zone(ids)\n\nassert zone.id == \"cs0-card-stack\"\nassert zone.item_selector == \"[data-card-role='focused']\"\nassert isinstance(zone.navigation, ScrollOnly)\nassert zone.zone_focus_classes == ()\nassert zone.item_focus_classes == ()\nassert zone.hidden_input_prefix == \"cs0-focused\"\nprint(\"Focus zone default tests passed!\")\n\nFocus zone default tests passed!\n\n\n\n# Test with custom parameters\nzone = create_card_stack_focus_zone(\n    ids,\n    on_focus_change=\"onCardFocusChange\",\n    hidden_input_prefix=\"sd-decomp-focused\",\n    data_attributes=(\"segment-index\",),\n)\nassert zone.on_focus_change == \"onCardFocusChange\"\nassert zone.hidden_input_prefix == \"sd-decomp-focused\"\nassert zone.data_attributes == (\"segment-index\",)\nprint(\"Focus zone custom parameter tests passed!\")\n\nFocus zone custom parameter tests passed!\n\n\n\n# Test multi-instance uniqueness\nids_a = CardStackHtmlIds(prefix=\"text\")\nids_b = CardStackHtmlIds(prefix=\"vad\")\nzone_a = create_card_stack_focus_zone(ids_a)\nzone_b = create_card_stack_focus_zone(ids_b)\nassert zone_a.id != zone_b.id\nassert zone_a.hidden_input_prefix != zone_b.hidden_input_prefix\nprint(\"Multi-instance focus zone tests passed!\")\n\nMulti-instance focus zone tests passed!",
    "crumbs": [
      "keyboard",
      "Actions"
    ]
  },
  {
    "objectID": "keyboard/actions.html#create_card_stack_focus_zone",
    "href": "keyboard/actions.html#create_card_stack_focus_zone",
    "title": "Actions",
    "section": "",
    "text": "Creates a FocusZone configured for the card stack viewport. Uses ScrollOnly navigation since all navigation is handled via HTMX button triggers, not the keyboard library’s built-in item navigation.\n\nsource\n\n\n\ndef create_card_stack_focus_zone(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    on_focus_change:Optional=None, # JS callback name on focus change\n    hidden_input_prefix:Optional=None, # Prefix for keyboard nav hidden inputs\n    data_attributes:Tuple=(), # Data attributes to track on focused items\n)-&gt;FocusZone: # Configured focus zone for the card stack\n\nCreate a focus zone for a card stack viewport.\n\n# Test create_card_stack_focus_zone\nids = CardStackHtmlIds(prefix=\"cs0\")\nzone = create_card_stack_focus_zone(ids)\n\nassert zone.id == \"cs0-card-stack\"\nassert zone.item_selector == \"[data-card-role='focused']\"\nassert isinstance(zone.navigation, ScrollOnly)\nassert zone.zone_focus_classes == ()\nassert zone.item_focus_classes == ()\nassert zone.hidden_input_prefix == \"cs0-focused\"\nprint(\"Focus zone default tests passed!\")\n\nFocus zone default tests passed!\n\n\n\n# Test with custom parameters\nzone = create_card_stack_focus_zone(\n    ids,\n    on_focus_change=\"onCardFocusChange\",\n    hidden_input_prefix=\"sd-decomp-focused\",\n    data_attributes=(\"segment-index\",),\n)\nassert zone.on_focus_change == \"onCardFocusChange\"\nassert zone.hidden_input_prefix == \"sd-decomp-focused\"\nassert zone.data_attributes == (\"segment-index\",)\nprint(\"Focus zone custom parameter tests passed!\")\n\nFocus zone custom parameter tests passed!\n\n\n\n# Test multi-instance uniqueness\nids_a = CardStackHtmlIds(prefix=\"text\")\nids_b = CardStackHtmlIds(prefix=\"vad\")\nzone_a = create_card_stack_focus_zone(ids_a)\nzone_b = create_card_stack_focus_zone(ids_b)\nassert zone_a.id != zone_b.id\nassert zone_a.hidden_input_prefix != zone_b.hidden_input_prefix\nprint(\"Multi-instance focus zone tests passed!\")\n\nMulti-instance focus zone tests passed!",
    "crumbs": [
      "keyboard",
      "Actions"
    ]
  },
  {
    "objectID": "keyboard/actions.html#create_card_stack_nav_actions",
    "href": "keyboard/actions.html#create_card_stack_nav_actions",
    "title": "Actions",
    "section": "create_card_stack_nav_actions",
    "text": "create_card_stack_nav_actions\nCreates the standard keyboard navigation actions for a card stack:\n\nArrowUp/Down: Navigate prev/next item (HTMX button trigger)\nCtrl+ArrowUp/Down: Page jump (JS callback)\nCtrl+Shift+ArrowUp/Down: First/last item (JS callback)\n[/]: Narrow/widen viewport (JS callback)\n-/=: Decrease/increase scale (JS callback)\n\nJS callbacks use prefix-unique global names that map to the namespaced window.cardStacks[prefix] functions.\n\nsource\n\ncreate_card_stack_nav_actions\n\ndef create_card_stack_nav_actions(\n    zone_id:str, # Focus zone ID to restrict actions to\n    button_ids:CardStackButtonIds, # Button IDs for HTMX triggers\n    config:CardStackConfig, # Config (for prefix-unique callback names)\n    disable_in_modes:Tuple=(), # Mode names that disable navigation\n)-&gt;Tuple: # Standard card stack navigation actions\n\nCreate standard keyboard navigation actions for a card stack.\n\nfrom cjm_fasthtml_card_stack.core.config import CardStackConfig, _reset_prefix_counter\n\n# Test create_card_stack_nav_actions returns 10 actions\n_reset_prefix_counter()\nconfig = CardStackConfig()\nbtn_ids = CardStackButtonIds(prefix=config.prefix)\nids = CardStackHtmlIds(prefix=config.prefix)\nzone = create_card_stack_focus_zone(ids)\n\nactions = create_card_stack_nav_actions(\n    zone_id=zone.id,\n    button_ids=btn_ids,\n    config=config,\n)\n\nassert len(actions) == 10\nprint(f\"Got {len(actions)} actions\")\n\nGot 10 actions\n\n\n\n# Test ArrowUp/Down actions use HTMX triggers\narrow_up = actions[0]\narrow_down = actions[1]\n\nassert arrow_up.key == \"ArrowUp\"\nassert arrow_up.htmx_trigger == btn_ids.nav_up\nassert arrow_up.zone_ids == (zone.id,)\n\nassert arrow_down.key == \"ArrowDown\"\nassert arrow_down.htmx_trigger == btn_ids.nav_down\nprint(\"Arrow key action tests passed!\")\n\nArrow key action tests passed!\n\n\n\n# Test Ctrl+Arrow actions use prefix-unique JS callbacks\npage_up = actions[2]\npage_down = actions[3]\n\nassert page_up.js_callback == \"cs0_jumpPageUp\"\nassert page_down.js_callback == \"cs0_jumpPageDown\"\nassert page_up.modifiers == frozenset({\"ctrl\"})\nprint(\"Page jump callback tests passed!\")\n\nPage jump callback tests passed!\n\n\n\n# Test Ctrl+Shift+Arrow actions use prefix-unique JS callbacks\nfirst_item = actions[4]\nlast_item = actions[5]\n\nassert first_item.js_callback == \"cs0_jumpToFirstItem\"\nassert last_item.js_callback == \"cs0_jumpToLastItem\"\nassert first_item.modifiers == frozenset({\"ctrl\", \"shift\"})\nprint(\"First/last callback tests passed!\")\n\nFirst/last callback tests passed!\n\n\n\n# Test width adjustment actions use prefix-unique JS callbacks\nnarrow = actions[6]\nwiden = actions[7]\n\nassert narrow.key == \"[\"\nassert narrow.js_callback == \"cs0_decreaseWidth\"\nassert widen.key == \"]\"\nassert widen.js_callback == \"cs0_increaseWidth\"\nprint(\"Width adjustment callback tests passed!\")\n\nWidth adjustment callback tests passed!\n\n\n\n# Test scale adjustment actions use prefix-unique JS callbacks\nscale_down = actions[8]\nscale_up = actions[9]\n\nassert scale_down.key == \"-\"\nassert scale_down.js_callback == \"cs0_decreaseScale\"\nassert scale_up.key == \"=\"\nassert scale_up.js_callback == \"cs0_increaseScale\"\nprint(\"Scale adjustment callback tests passed!\")\n\n# Test disable_in_modes filtering\nactions_with_modes = create_card_stack_nav_actions(\n    zone_id=zone.id,\n    button_ids=btn_ids,\n    config=config,\n    disable_in_modes=(\"split\", \"edit\"),\n)\n\n# Navigation actions should have not_modes set\nassert actions_with_modes[0].not_modes == (\"split\", \"edit\")\nassert actions_with_modes[1].not_modes == (\"split\", \"edit\")\nassert actions_with_modes[2].not_modes == (\"split\", \"edit\")\n\n# Width and scale actions should NOT have not_modes (available in any mode)\nassert actions_with_modes[6].not_modes == None\nassert actions_with_modes[7].not_modes == None\nassert actions_with_modes[8].not_modes == None\nassert actions_with_modes[9].not_modes == None\nprint(\"Mode filtering tests passed!\")\n\nScale adjustment callback tests passed!\nMode filtering tests passed!\n\n\n\n# Test multi-instance: different prefixes produce different callback names\nconfig_a = CardStackConfig(prefix=\"text\")\nconfig_b = CardStackConfig(prefix=\"vad\")\nbtn_a = CardStackButtonIds(prefix=\"text\")\nbtn_b = CardStackButtonIds(prefix=\"vad\")\nids_a = CardStackHtmlIds(prefix=\"text\")\nids_b = CardStackHtmlIds(prefix=\"vad\")\n\nactions_a = create_card_stack_nav_actions(ids_a.card_stack, btn_a, config_a)\nactions_b = create_card_stack_nav_actions(ids_b.card_stack, btn_b, config_b)\n\n# HTMX triggers are different (different button IDs)\nassert actions_a[0].htmx_trigger != actions_b[0].htmx_trigger\n\n# JS callbacks are different (different prefixes)\nassert actions_a[2].js_callback == \"text_jumpPageUp\"\nassert actions_b[2].js_callback == \"vad_jumpPageUp\"\nprint(\"Multi-instance action tests passed!\")\n\nMulti-instance action tests passed!",
    "crumbs": [
      "keyboard",
      "Actions"
    ]
  },
  {
    "objectID": "keyboard/actions.html#build_card_stack_url_map",
    "href": "keyboard/actions.html#build_card_stack_url_map",
    "title": "Actions",
    "section": "build_card_stack_url_map",
    "text": "build_card_stack_url_map\nReturns a dict mapping all card stack button IDs to their route URLs, for use as (or merged into) the url_map parameter of render_keyboard_system.\nThe keyboard system uses this map to create hidden HTMX buttons in the DOM. The JS callbacks (page jump, first/last) and the HTMX-triggered actions (nav up/down) both rely on these buttons existing.\nConsumer merges with their own action URLs:\nurl_map = {**build_card_stack_url_map(btn_ids, urls), **my_workflow_urls}\n\nsource\n\nbuild_card_stack_url_map\n\ndef build_card_stack_url_map(\n    button_ids:CardStackButtonIds, # Button IDs for this card stack instance\n    urls:CardStackUrls, # URL bundle for routing\n)-&gt;Dict: # Mapping of button ID -&gt; route URL\n\nBuild url_map for render_keyboard_system with all card stack navigation buttons.\nReturns a dict mapping button IDs to URLs for all navigation actions: nav_up, nav_down, nav_first, nav_last, nav_page_up, nav_page_down.\nMerge with consumer’s own action URLs when building the keyboard system: url_map = {build_card_stack_url_map(btn_ids, urls), my_action_urls}\n\nfrom cjm_fasthtml_card_stack.core.models import CardStackUrls\nfrom cjm_fasthtml_card_stack.core.config import CardStackConfig\n\n# Test build_card_stack_url_map\n_reset_prefix_counter()\nconfig = CardStackConfig()\nids = CardStackHtmlIds(prefix=config.prefix)\nbtn_ids = CardStackButtonIds(prefix=config.prefix)\nurls = CardStackUrls(\n    nav_up=\"/cs/nav_up\", nav_down=\"/cs/nav_down\",\n    nav_first=\"/cs/nav_first\", nav_last=\"/cs/nav_last\",\n    nav_page_up=\"/cs/nav_page_up\", nav_page_down=\"/cs/nav_page_down\",\n    nav_to_index=\"/cs/nav_to_index\",\n    update_viewport=\"/cs/update_viewport\",\n    save_width=\"/cs/save_width\", save_scale=\"/cs/save_scale\",\n)\n\nurl_map = build_card_stack_url_map(btn_ids, urls)\n\n# Verify all 6 navigation buttons are mapped\nassert len(url_map) == 6\nassert url_map[btn_ids.nav_up] == urls.nav_up\nassert url_map[btn_ids.nav_down] == urls.nav_down\nassert url_map[btn_ids.nav_first] == urls.nav_first\nassert url_map[btn_ids.nav_last] == urls.nav_last\nassert url_map[btn_ids.nav_page_up] == urls.nav_page_up\nassert url_map[btn_ids.nav_page_down] == urls.nav_page_down\n\n# Test merging with consumer urls\nmy_urls = {\"my-split-btn\": \"/split\", \"my-merge-btn\": \"/merge\"}\nmerged = {**url_map, **my_urls}\nassert len(merged) == 8\nprint(\"build_card_stack_url_map tests passed!\")\n\nbuild_card_stack_url_map tests passed!",
    "crumbs": [
      "keyboard",
      "Actions"
    ]
  },
  {
    "objectID": "keyboard/actions.html#render_card_stack_action_buttons",
    "href": "keyboard/actions.html#render_card_stack_action_buttons",
    "title": "Actions",
    "section": "render_card_stack_action_buttons",
    "text": "render_card_stack_action_buttons\nRenders hidden HTMX buttons for the JS-callback-triggered navigation actions (page jump, first/last). These are NOT created by render_keyboard_system because the corresponding KeyAction definitions use js_callback instead of htmx_trigger.\nThe full chain is: 1. Keyboard press → KeyAction with js_callback 2. Keyboard library calls window['cs0_jumpPageUp']() 3. Global wrapper calls window.cardStacks['cs0'].jumpPageUp() 4. JS function calls document.getElementById('cs0-btn-nav-page-up').click() 5. Hidden button fires HTMX POST to the route\nNote: nav_up/nav_down buttons are created by render_keyboard_system (since those KeyActions use htmx_trigger). This function creates the remaining 4 navigation buttons that the keyboard system skips.\n\nsource\n\nrender_card_stack_action_buttons\n\ndef render_card_stack_action_buttons(\n    button_ids:CardStackButtonIds, # Button IDs for this card stack instance\n    urls:CardStackUrls, # URL bundle for routing\n    ids:CardStackHtmlIds, # HTML IDs (for hx-include of focused_index_input)\n)-&gt;FT: # Div containing hidden action buttons\n\nRender hidden HTMX buttons for JS-callback-triggered navigation actions.\nCreates buttons for: page_up, page_down, first, last. These are clicked programmatically by the card stack’s JS functions. Must be included in the DOM alongside the keyboard system’s own buttons.\n\nfrom fasthtml.common import to_xml\n\n# Test render_card_stack_action_buttons\n_reset_prefix_counter()\nconfig = CardStackConfig()\nids = CardStackHtmlIds(prefix=config.prefix)\nbtn_ids = CardStackButtonIds(prefix=config.prefix)\n\nbuttons_div = render_card_stack_action_buttons(btn_ids, urls, ids)\nhtml = to_xml(buttons_div)\n\n# Verify all 4 hidden buttons are present with correct IDs\nassert btn_ids.nav_page_up in html\nassert btn_ids.nav_page_down in html\nassert btn_ids.nav_first in html\nassert btn_ids.nav_last in html\n\n# Verify HTMX post URLs\nassert urls.nav_page_up in html\nassert urls.nav_page_down in html\nassert urls.nav_first in html\nassert urls.nav_last in html\n\n# Verify hx-include references focused_index_input\nassert ids.focused_index_input in html\n\n# Verify hidden class (not inline style)\nassert 'class=\"hidden\"' in html\n\n# Verify nav_up/nav_down are NOT included (keyboard system handles those)\nassert btn_ids.nav_up not in html\nassert btn_ids.nav_down not in html\n\nprint(\"render_card_stack_action_buttons tests passed!\")\n\nrender_card_stack_action_buttons tests passed!\n\n\n\nfrom cjm_fasthtml_keyboard_navigation.core.modes import KeyboardMode\nfrom cjm_fasthtml_keyboard_navigation.core.manager import ZoneManager\n\n# Consumer creates zone and gets library nav actions\n_reset_prefix_counter()\nconfig = CardStackConfig()\nids = CardStackHtmlIds(prefix=config.prefix)\nbtn_ids = CardStackButtonIds(prefix=config.prefix)\n\nzone = create_card_stack_focus_zone(ids)\nnav_actions = create_card_stack_nav_actions(\n    zone.id, btn_ids, config, disable_in_modes=(\"split\",)\n)\n\n# Consumer adds their own actions\nconsumer_actions = (\n    KeyAction(\n        key=\"Enter\",\n        htmx_trigger=\"my-split-btn\",\n        not_modes=(\"split\",),\n        description=\"Enter split mode\",\n    ),\n    KeyAction(\n        key=\"Backspace\",\n        htmx_trigger=\"my-merge-btn\",\n        not_modes=(\"split\",),\n        description=\"Merge with previous\",\n    ),\n)\n\n# Consumer defines modes\nsplit_mode = KeyboardMode(\n    name=\"split\",\n    navigation_override=ScrollOnly(),\n    indicator_text=\"Split Mode\",\n)\n\n# Consumer assembles full manager\nmanager = ZoneManager(\n    zones=(zone,),\n    actions=nav_actions + consumer_actions,\n    modes=(split_mode,),\n    prev_zone_key=\"\",\n    next_zone_key=\"\",\n    state_hidden_inputs=True,\n)\n\nassert len(manager.zones) == 1\nassert len(manager.actions) == 12  # 10 library + 2 consumer\nassert len(manager.modes) == 1\nprint(f\"ZoneManager assembled: {len(manager.actions)} actions, {len(manager.modes)} modes\")\n\nZoneManager assembled: 12 actions, 1 modes",
    "crumbs": [
      "keyboard",
      "Actions"
    ]
  },
  {
    "objectID": "core/models.html",
    "href": "core/models.html",
    "title": "Models",
    "section": "",
    "text": "Runtime-changeable state that the consumer persists. All fields use simple types for trivial JSON/SQLite serialization.\n\nsource\n\n\n\ndef CardStackState(\n    focused_index:int=0, visible_count:int=3, card_width:int=80, card_scale:int=100, active_mode:Optional=None,\n    focus_position:Optional=None\n)-&gt;None:\n\nViewport state for a card stack instance.\n\n# Test CardStackState defaults\nstate = CardStackState()\nassert state.focused_index == 0\nassert state.visible_count == 3\nassert state.card_width == 80\nassert state.card_scale == 100\nassert state.active_mode is None\nassert state.focus_position is None\nprint(\"CardStackState default tests passed!\")\n\nCardStackState default tests passed!\n\n\n\n# Test CardStackState with custom values\nstate = CardStackState(\n    focused_index=5,\n    visible_count=7,\n    card_width=60,\n    card_scale=150,\n    active_mode=\"split\",\n    focus_position=-1,\n)\nassert state.focused_index == 5\nassert state.visible_count == 7\nassert state.card_width == 60\nassert state.card_scale == 150\nassert state.active_mode == \"split\"\nassert state.focus_position == -1\nprint(\"CardStackState custom value tests passed!\")\n\nCardStackState custom value tests passed!\n\n\n\n# Test CardStackState mutability (in-place mutation pattern)\nstate = CardStackState()\nstate.focused_index = 10\nstate.active_mode = \"edit\"\nassert state.focused_index == 10\nassert state.active_mode == \"edit\"\nprint(\"CardStackState mutation tests passed!\")\n\nCardStackState mutation tests passed!",
    "crumbs": [
      "core",
      "Models"
    ]
  },
  {
    "objectID": "core/models.html#cardstackstate",
    "href": "core/models.html#cardstackstate",
    "title": "Models",
    "section": "",
    "text": "Runtime-changeable state that the consumer persists. All fields use simple types for trivial JSON/SQLite serialization.\n\nsource\n\n\n\ndef CardStackState(\n    focused_index:int=0, visible_count:int=3, card_width:int=80, card_scale:int=100, active_mode:Optional=None,\n    focus_position:Optional=None\n)-&gt;None:\n\nViewport state for a card stack instance.\n\n# Test CardStackState defaults\nstate = CardStackState()\nassert state.focused_index == 0\nassert state.visible_count == 3\nassert state.card_width == 80\nassert state.card_scale == 100\nassert state.active_mode is None\nassert state.focus_position is None\nprint(\"CardStackState default tests passed!\")\n\nCardStackState default tests passed!\n\n\n\n# Test CardStackState with custom values\nstate = CardStackState(\n    focused_index=5,\n    visible_count=7,\n    card_width=60,\n    card_scale=150,\n    active_mode=\"split\",\n    focus_position=-1,\n)\nassert state.focused_index == 5\nassert state.visible_count == 7\nassert state.card_width == 60\nassert state.card_scale == 150\nassert state.active_mode == \"split\"\nassert state.focus_position == -1\nprint(\"CardStackState custom value tests passed!\")\n\nCardStackState custom value tests passed!\n\n\n\n# Test CardStackState mutability (in-place mutation pattern)\nstate = CardStackState()\nstate.focused_index = 10\nstate.active_mode = \"edit\"\nassert state.focused_index == 10\nassert state.active_mode == \"edit\"\nprint(\"CardStackState mutation tests passed!\")\n\nCardStackState mutation tests passed!",
    "crumbs": [
      "core",
      "Models"
    ]
  },
  {
    "objectID": "core/models.html#cardrendercontext",
    "href": "core/models.html#cardrendercontext",
    "title": "Models",
    "section": "CardRenderContext",
    "text": "CardRenderContext\nPassed to the consumer’s render_card(item, context) callback. Provides all positional and state information the consumer needs to render a card.\n\nsource\n\nCardRenderContext\n\ndef CardRenderContext(\n    card_role:str, index:int, total_items:int, is_first:bool, is_last:bool, active_mode:Optional, card_scale:int,\n    distance_from_focus:int\n)-&gt;None:\n\nContext passed to the consumer’s render_card callback.\n\n# Test CardRenderContext for focused card\nctx = CardRenderContext(\n    card_role=\"focused\",\n    index=5,\n    total_items=20,\n    is_first=False,\n    is_last=False,\n    active_mode=None,\n    card_scale=100,\n    distance_from_focus=0,\n)\nassert ctx.card_role == \"focused\"\nassert ctx.distance_from_focus == 0\nassert not ctx.is_first\nassert not ctx.is_last\nprint(\"CardRenderContext focused card tests passed!\")\n\nCardRenderContext focused card tests passed!\n\n\n\n# Test CardRenderContext for context cards at various distances\nctx_before = CardRenderContext(\n    card_role=\"context\",\n    index=3,\n    total_items=20,\n    is_first=False,\n    is_last=False,\n    active_mode=\"split\",\n    card_scale=75,\n    distance_from_focus=-2,\n)\nassert ctx_before.card_role == \"context\"\nassert ctx_before.distance_from_focus == -2\nassert ctx_before.active_mode == \"split\"\nassert ctx_before.card_scale == 75\n\nctx_after = CardRenderContext(\n    card_role=\"context\",\n    index=7,\n    total_items=20,\n    is_first=False,\n    is_last=False,\n    active_mode=None,\n    card_scale=100,\n    distance_from_focus=2,\n)\nassert ctx_after.distance_from_focus == 2\nprint(\"CardRenderContext distance tests passed!\")\n\nCardRenderContext distance tests passed!\n\n\n\n# Test CardRenderContext edge items\nctx_first = CardRenderContext(\n    card_role=\"focused\",\n    index=0,\n    total_items=10,\n    is_first=True,\n    is_last=False,\n    active_mode=None,\n    card_scale=100,\n    distance_from_focus=0,\n)\nassert ctx_first.is_first\nassert not ctx_first.is_last\nassert ctx_first.index == 0\n\nctx_last = CardRenderContext(\n    card_role=\"focused\",\n    index=9,\n    total_items=10,\n    is_first=False,\n    is_last=True,\n    active_mode=None,\n    card_scale=100,\n    distance_from_focus=0,\n)\nassert not ctx_last.is_first\nassert ctx_last.is_last\nassert ctx_last.index == 9\nprint(\"CardRenderContext edge item tests passed!\")\n\nCardRenderContext edge item tests passed!",
    "crumbs": [
      "core",
      "Models"
    ]
  },
  {
    "objectID": "core/models.html#cardstackurls",
    "href": "core/models.html#cardstackurls",
    "title": "Models",
    "section": "CardStackUrls",
    "text": "CardStackUrls\nURL bundle for routing. Built from route .to() calls inside the convenience router, or constructed manually by the consumer.\n\nsource\n\nCardStackUrls\n\ndef CardStackUrls(\n    nav_up:str='', nav_down:str='', nav_first:str='', nav_last:str='', nav_page_up:str='', nav_page_down:str='',\n    nav_to_index:str='', update_viewport:str='', save_width:str='', save_scale:str=''\n)-&gt;None:\n\nURL bundle for card stack navigation and viewport operations.\n\n# Test CardStackUrls defaults\nurls = CardStackUrls()\nassert urls.nav_up == \"\"\nassert urls.save_scale == \"\"\n\n# Test with actual URL values\nurls = CardStackUrls(\n    nav_up=\"/card-stack/nav_up\",\n    nav_down=\"/card-stack/nav_down\",\n    nav_first=\"/card-stack/nav_first\",\n    nav_last=\"/card-stack/nav_last\",\n    nav_page_up=\"/card-stack/nav_page_up\",\n    nav_page_down=\"/card-stack/nav_page_down\",\n    nav_to_index=\"/card-stack/nav_to_index\",\n    update_viewport=\"/card-stack/update_viewport\",\n    save_width=\"/card-stack/save_width\",\n    save_scale=\"/card-stack/save_scale\",\n)\nassert urls.nav_up == \"/card-stack/nav_up\"\nassert urls.nav_to_index == \"/card-stack/nav_to_index\"\nassert urls.save_scale == \"/card-stack/save_scale\"\nprint(\"CardStackUrls tests passed!\")\n\nCardStackUrls tests passed!",
    "crumbs": [
      "core",
      "Models"
    ]
  },
  {
    "objectID": "core/html_ids.html",
    "href": "core/html_ids.html",
    "title": "HTML IDs",
    "section": "",
    "text": "All DOM element IDs are derived from a configurable prefix, enabling multiple card stack instances on the same page without ID collisions.\n\nsource\n\n\n\ndef CardStackHtmlIds(\n    prefix:str\n)-&gt;None:\n\nPrefix-based HTML ID generator for card stack DOM elements.\n\n# Test CardStackHtmlIds with default-style prefix\nids = CardStackHtmlIds(prefix=\"cs0\")\nassert ids.card_stack == \"cs0-card-stack\"\nassert ids.card_stack_inner == \"cs0-card-stack-inner\"\nassert ids.card_stack_empty == \"cs0-card-stack-empty\"\nassert ids.viewport_section_before == \"cs0-viewport-section-before\"\nassert ids.viewport_section_focused == \"cs0-viewport-section-focused\"\nassert ids.viewport_section_after == \"cs0-viewport-section-after\"\nassert ids.card_count_select == \"cs0-card-count-select\"\nassert ids.width_slider == \"cs0-width-slider\"\nassert ids.scale_slider == \"cs0-scale-slider\"\nassert ids.progress == \"cs0-progress\"\nassert ids.loading == \"cs0-loading\"\nassert ids.focused_index_input == \"cs0-focused-index\"\nprint(\"CardStackHtmlIds default prefix tests passed!\")\n\nCardStackHtmlIds default prefix tests passed!\n\n\n\n# Test viewport_slot method (unified IDs for items and placeholders)\nids = CardStackHtmlIds(prefix=\"cs0\")\n# Real items\nassert ids.viewport_slot(0) == \"cs0-item-slot-0\"\nassert ids.viewport_slot(3) == \"cs0-item-slot-3\"\nassert ids.viewport_slot(8) == \"cs0-item-slot-8\"\n# Placeholders (negative indices for before-start)\nassert ids.viewport_slot(-1) == \"cs0-item-slot--1\"\nassert ids.viewport_slot(-2) == \"cs0-item-slot--2\"\n# Placeholders (indices &gt;= total_items for after-end)\nassert ids.viewport_slot(20) == \"cs0-item-slot-20\"\nassert ids.viewport_slot(21) == \"cs0-item-slot-21\"\nprint(\"Viewport slot tests passed!\")\n\nViewport slot tests passed!\n\n\n\n# Test multi-instance uniqueness\nids_a = CardStackHtmlIds(prefix=\"text-stack\")\nids_b = CardStackHtmlIds(prefix=\"vad-stack\")\nassert ids_a.card_stack == \"text-stack-card-stack\"\nassert ids_b.card_stack == \"vad-stack-card-stack\"\nassert ids_a.card_stack != ids_b.card_stack\nassert ids_a.viewport_slot(0) != ids_b.viewport_slot(0)\nassert ids_a.viewport_slot(-1) != ids_b.viewport_slot(-1)\nprint(\"Multi-instance uniqueness tests passed!\")\n\nMulti-instance uniqueness tests passed!",
    "crumbs": [
      "core",
      "HTML IDs"
    ]
  },
  {
    "objectID": "core/html_ids.html#cardstackhtmlids",
    "href": "core/html_ids.html#cardstackhtmlids",
    "title": "HTML IDs",
    "section": "",
    "text": "All DOM element IDs are derived from a configurable prefix, enabling multiple card stack instances on the same page without ID collisions.\n\nsource\n\n\n\ndef CardStackHtmlIds(\n    prefix:str\n)-&gt;None:\n\nPrefix-based HTML ID generator for card stack DOM elements.\n\n# Test CardStackHtmlIds with default-style prefix\nids = CardStackHtmlIds(prefix=\"cs0\")\nassert ids.card_stack == \"cs0-card-stack\"\nassert ids.card_stack_inner == \"cs0-card-stack-inner\"\nassert ids.card_stack_empty == \"cs0-card-stack-empty\"\nassert ids.viewport_section_before == \"cs0-viewport-section-before\"\nassert ids.viewport_section_focused == \"cs0-viewport-section-focused\"\nassert ids.viewport_section_after == \"cs0-viewport-section-after\"\nassert ids.card_count_select == \"cs0-card-count-select\"\nassert ids.width_slider == \"cs0-width-slider\"\nassert ids.scale_slider == \"cs0-scale-slider\"\nassert ids.progress == \"cs0-progress\"\nassert ids.loading == \"cs0-loading\"\nassert ids.focused_index_input == \"cs0-focused-index\"\nprint(\"CardStackHtmlIds default prefix tests passed!\")\n\nCardStackHtmlIds default prefix tests passed!\n\n\n\n# Test viewport_slot method (unified IDs for items and placeholders)\nids = CardStackHtmlIds(prefix=\"cs0\")\n# Real items\nassert ids.viewport_slot(0) == \"cs0-item-slot-0\"\nassert ids.viewport_slot(3) == \"cs0-item-slot-3\"\nassert ids.viewport_slot(8) == \"cs0-item-slot-8\"\n# Placeholders (negative indices for before-start)\nassert ids.viewport_slot(-1) == \"cs0-item-slot--1\"\nassert ids.viewport_slot(-2) == \"cs0-item-slot--2\"\n# Placeholders (indices &gt;= total_items for after-end)\nassert ids.viewport_slot(20) == \"cs0-item-slot-20\"\nassert ids.viewport_slot(21) == \"cs0-item-slot-21\"\nprint(\"Viewport slot tests passed!\")\n\nViewport slot tests passed!\n\n\n\n# Test multi-instance uniqueness\nids_a = CardStackHtmlIds(prefix=\"text-stack\")\nids_b = CardStackHtmlIds(prefix=\"vad-stack\")\nassert ids_a.card_stack == \"text-stack-card-stack\"\nassert ids_b.card_stack == \"vad-stack-card-stack\"\nassert ids_a.card_stack != ids_b.card_stack\nassert ids_a.viewport_slot(0) != ids_b.viewport_slot(0)\nassert ids_a.viewport_slot(-1) != ids_b.viewport_slot(-1)\nprint(\"Multi-instance uniqueness tests passed!\")\n\nMulti-instance uniqueness tests passed!",
    "crumbs": [
      "core",
      "HTML IDs"
    ]
  },
  {
    "objectID": "routes/handlers.html",
    "href": "routes/handlers.html",
    "title": "Handlers",
    "section": "",
    "text": "Composable functions that build HTMX response parts. Consumers can use these directly or call the higher-level card_stack_navigate functions.\n\nsource\n\n\n\ndef build_slots_response(\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n)-&gt;List: # OOB slot elements (3 viewport sections)\n\nBuild OOB slot updates for the viewport sections only.\n\nsource\n\n\n\n\ndef build_nav_response(\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n    progress_label:str='Item', # Label for progress indicator\n    form_input_name:str='focused_index', # Name for the focused index hidden input\n)-&gt;Tuple: # OOB elements (slots + progress + focus)\n\nBuild full OOB response for navigation: slots + progress + focus inputs.",
    "crumbs": [
      "routes",
      "Handlers"
    ]
  },
  {
    "objectID": "routes/handlers.html#response-builders",
    "href": "routes/handlers.html#response-builders",
    "title": "Handlers",
    "section": "",
    "text": "Composable functions that build HTMX response parts. Consumers can use these directly or call the higher-level card_stack_navigate functions.\n\nsource\n\n\n\ndef build_slots_response(\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n)-&gt;List: # OOB slot elements (3 viewport sections)\n\nBuild OOB slot updates for the viewport sections only.\n\nsource\n\n\n\n\ndef build_nav_response(\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n    progress_label:str='Item', # Label for progress indicator\n    form_input_name:str='focused_index', # Name for the focused index hidden input\n)-&gt;Tuple: # OOB elements (slots + progress + focus)\n\nBuild full OOB response for navigation: slots + progress + focus inputs.",
    "crumbs": [
      "routes",
      "Handlers"
    ]
  },
  {
    "objectID": "routes/handlers.html#navigation",
    "href": "routes/handlers.html#navigation",
    "title": "Handlers",
    "section": "Navigation",
    "text": "Navigation\n\nsource\n\ncard_stack_navigate\n\ndef card_stack_navigate(\n    direction:str, # \"up\", \"down\", \"first\", \"last\", \"page_up\", \"page_down\"\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state (mutated in place)\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n    progress_label:str='Item', # Label for progress indicator\n    form_input_name:str='focused_index', # Name for the focused index hidden input\n)-&gt;Tuple: # OOB elements (slots + progress + focus)\n\nNavigate to a different item. Mutates state.focused_index in place.\n\nsource\n\n\ncard_stack_navigate_to_index\n\ndef card_stack_navigate_to_index(\n    target_index:int, # Target item index to navigate to\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state (mutated in place)\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n    progress_label:str='Item', # Label for progress indicator\n    form_input_name:str='focused_index', # Name for the focused index hidden input\n)-&gt;Tuple: # OOB elements (slots + progress + focus)\n\nNavigate to a specific item index. Mutates state.focused_index in place.",
    "crumbs": [
      "routes",
      "Handlers"
    ]
  },
  {
    "objectID": "routes/handlers.html#viewport-update",
    "href": "routes/handlers.html#viewport-update",
    "title": "Handlers",
    "section": "Viewport Update",
    "text": "Viewport Update\n\nsource\n\ncard_stack_update_viewport\n\ndef card_stack_update_viewport(\n    visible_count:int, # New number of visible cards\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state (mutated in place)\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n)-&gt;Tuple: # OOB section elements (3 viewport sections)\n\nUpdate viewport with new card count via OOB section swaps. Mutates state.visible_count in place.",
    "crumbs": [
      "routes",
      "Handlers"
    ]
  },
  {
    "objectID": "routes/handlers.html#preference-persistence",
    "href": "routes/handlers.html#preference-persistence",
    "title": "Handlers",
    "section": "Preference Persistence",
    "text": "Preference Persistence\n\nsource\n\ncard_stack_save_width\n\ndef card_stack_save_width(\n    state:CardStackState, # Current card stack state (mutated in place)\n    card_width:int, # Card stack width in rem\n    config:CardStackConfig, # Card stack configuration (for clamping bounds)\n)-&gt;None: # No response (swap=none on client)\n\nSave card stack width. Mutates state.card_width in place.\n\nsource\n\n\ncard_stack_save_scale\n\ndef card_stack_save_scale(\n    state:CardStackState, # Current card stack state (mutated in place)\n    card_scale:int, # Card stack scale percentage\n    config:CardStackConfig, # Card stack configuration (for clamping bounds)\n)-&gt;None: # No response (swap=none on client)\n\nSave card stack scale. Mutates state.card_scale in place.",
    "crumbs": [
      "routes",
      "Handlers"
    ]
  },
  {
    "objectID": "routes/handlers.html#tests",
    "href": "routes/handlers.html#tests",
    "title": "Handlers",
    "section": "Tests",
    "text": "Tests\n\nfrom cjm_fasthtml_card_stack.core.config import _reset_prefix_counter\nfrom cjm_fasthtml_card_stack.core.models import CardStackState, CardRenderContext, CardStackUrls\nfrom cjm_fasthtml_card_stack.core.html_ids import CardStackHtmlIds\n\n# Simple render_card for testing\nfrom fasthtml.common import Div, Span\n\ndef _test_render_card(item, context: CardRenderContext):\n    return Div(Span(f\"Item {context.index}: {item}\"), cls=f\"card-{context.card_role}\")\n\n# Setup test fixtures\n_reset_prefix_counter()\n_test_config = CardStackConfig(prefix=\"test\")\n_test_ids = CardStackHtmlIds(prefix=\"test\")\n_test_urls = CardStackUrls(\n    nav_up=\"/nav_up\", nav_down=\"/nav_down\",\n    nav_first=\"/nav_first\", nav_last=\"/nav_last\",\n    nav_page_up=\"/nav_page_up\", nav_page_down=\"/nav_page_down\",\n    nav_to_index=\"/nav_to_index\",\n    update_viewport=\"/update_viewport\",\n    save_width=\"/save_width\", save_scale=\"/save_scale\",\n)\n_test_items = [f\"Item {i}\" for i in range(20)]\n\nprint(\"Test fixtures ready.\")\n\nTest fixtures ready.\n\n\n\n# Test card_stack_navigate — basic down navigation\nstate = CardStackState(focused_index=5, visible_count=3)\nresult = card_stack_navigate(\n    \"down\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card\n)\nassert state.focused_index == 6  # Mutated in place\nassert len(result) &gt; 0  # Returns OOB elements\nprint(\"Navigate down test passed!\")\n\nNavigate down test passed!\n\n\n\n# Test card_stack_navigate — boundary clamping\nstate = CardStackState(focused_index=0, visible_count=3)\ncard_stack_navigate(\"up\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card)\nassert state.focused_index == 0  # Can't go below 0\n\nstate = CardStackState(focused_index=19, visible_count=3)\ncard_stack_navigate(\"down\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card)\nassert state.focused_index == 19  # Can't go above total-1\nprint(\"Navigate boundary clamping tests passed!\")\n\nNavigate boundary clamping tests passed!\n\n\n\n# Test card_stack_navigate — first/last\nstate = CardStackState(focused_index=10, visible_count=3)\ncard_stack_navigate(\"first\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card)\nassert state.focused_index == 0\n\ncard_stack_navigate(\"last\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card)\nassert state.focused_index == 19\nprint(\"Navigate first/last tests passed!\")\n\nNavigate first/last tests passed!\n\n\n\n# Test card_stack_navigate — page jump uses visible_count - 1\nstate = CardStackState(focused_index=10, visible_count=5)\ncard_stack_navigate(\"page_down\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card)\nassert state.focused_index == 14  # 10 + (5-1) = 14\n\nstate = CardStackState(focused_index=10, visible_count=3)\ncard_stack_navigate(\"page_up\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card)\nassert state.focused_index == 8  # 10 - (3-1) = 8\n\n# Single card: page jump = 1\nstate = CardStackState(focused_index=10, visible_count=1)\ncard_stack_navigate(\"page_down\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card)\nassert state.focused_index == 11  # 10 + max(1, 1-1) = 10 + 1 = 11\nprint(\"Page jump tests passed!\")\n\nPage jump tests passed!\n\n\n\n# Test card_stack_navigate — empty items\nstate = CardStackState(focused_index=0, visible_count=3)\nresult = card_stack_navigate(\n    \"down\", [], state, _test_config, _test_ids, _test_urls, _test_render_card\n)\nassert state.focused_index == 0  # Unchanged\nassert len(result) &gt; 0  # Still returns elements (empty viewport sections)\nprint(\"Empty items navigate test passed!\")\n\nEmpty items navigate test passed!\n\n\n\n# Test card_stack_navigate_to_index\nstate = CardStackState(focused_index=0, visible_count=3)\nresult = card_stack_navigate_to_index(\n    15, _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card\n)\nassert state.focused_index == 15\n\n# Clamps out-of-range\ncard_stack_navigate_to_index(\n    100, _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card\n)\nassert state.focused_index == 19  # Clamped to total-1\n\ncard_stack_navigate_to_index(\n    -5, _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card\n)\nassert state.focused_index == 0  # Clamped to 0\nprint(\"Navigate to index tests passed!\")\n\nNavigate to index tests passed!\n\n\n\n# Test form_input_name is passed through navigation\nfrom fasthtml.common import to_xml\n\nstate = CardStackState(focused_index=5, visible_count=3)\nresult = card_stack_navigate(\n    \"down\", _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card,\n    form_input_name=\"segment_index\"\n)\n# Find the Hidden input in the result tuple\nhidden_found = False\nfor el in result:\n    html = to_xml(el)\n    if 'name=\"segment_index\"' in html:\n        hidden_found = True\n        assert 'value=\"6\"' in html  # focused_index after nav down from 5\n        break\nassert hidden_found, \"Hidden input with custom form_input_name not found in response\"\nprint(\"form_input_name passthrough test passed!\")\n\nform_input_name passthrough test passed!\n\n\n\n# Test card_stack_update_viewport returns OOB section tuple\nfrom fasthtml.common import to_xml\n\nstate = CardStackState(focused_index=5, visible_count=3)\nresult = card_stack_update_viewport(\n    7, _test_items, state, _test_config, _test_ids, _test_urls, _test_render_card\n)\nassert state.visible_count == 7  # Mutated in place\nassert isinstance(result, tuple)  # Returns tuple of OOB sections\nassert len(result) == 3  # 3 viewport sections (before, focused, after)\n\n# Verify each section has OOB swap attribute\nfor section in result:\n    html = to_xml(section)\n    assert 'hx-swap-oob=\"innerHTML\"' in html\n\n# Verify section IDs\nassert f'id=\"{_test_ids.viewport_section_before}\"' in to_xml(result[0])\nassert f'id=\"{_test_ids.viewport_section_focused}\"' in to_xml(result[1])\nassert f'id=\"{_test_ids.viewport_section_after}\"' in to_xml(result[2])\nprint(\"Update viewport OOB test passed!\")\n\nUpdate viewport OOB test passed!\n\n\n\n# Test card_stack_save_width\nstate = CardStackState(card_width=80)\ncard_stack_save_width(state, 60, _test_config)\nassert state.card_width == 60\n\n# Clamping above max\ncard_stack_save_width(state, 200, _test_config)\nassert state.card_width == _test_config.card_width_max  # 120\n\n# Clamping below min\ncard_stack_save_width(state, 10, _test_config)\nassert state.card_width == _test_config.card_width_min  # 30\nprint(\"Save width tests passed!\")\n\nSave width tests passed!\n\n\n\n# Test card_stack_save_scale\nstate = CardStackState(card_scale=100)\ncard_stack_save_scale(state, 150, _test_config)\nassert state.card_scale == 150\n\n# Clamping above max\ncard_stack_save_scale(state, 300, _test_config)\nassert state.card_scale == _test_config.card_scale_max  # 200\n\n# Clamping below min\ncard_stack_save_scale(state, 10, _test_config)\nassert state.card_scale == _test_config.card_scale_min  # 50\nprint(\"Save scale tests passed!\")\n\nSave scale tests passed!",
    "crumbs": [
      "routes",
      "Handlers"
    ]
  },
  {
    "objectID": "helpers/focus.html",
    "href": "helpers/focus.html",
    "title": "Focus",
    "section": "",
    "text": "Converts the focus_position setting (which uses Python negative indexing convention) into an actual 0-indexed slot position within the viewport.\n\nsource\n\n\n\ndef resolve_focus_slot(\n    focus_position:Optional, # Slot offset (None=center, -1=bottom, 0=top)\n    visible_count:int, # Number of visible card slots\n)-&gt;int: # Resolved 0-indexed slot position\n\nResolve focus_position to an actual slot index within the viewport.\n\n# Test center focus (None)\nassert resolve_focus_slot(None, 5) == 2  # 5 cards -&gt; slot 2 (middle)\nassert resolve_focus_slot(None, 3) == 1  # 3 cards -&gt; slot 1\nassert resolve_focus_slot(None, 1) == 0  # 1 card -&gt; slot 0\nassert resolve_focus_slot(None, 7) == 3  # 7 cards -&gt; slot 3\nprint(\"Center focus tests passed!\")\n\nCenter focus tests passed!\n\n\n\n# Test bottom focus (-1)\nassert resolve_focus_slot(-1, 5) == 4  # Last slot\nassert resolve_focus_slot(-1, 3) == 2\nassert resolve_focus_slot(-1, 1) == 0\n\n# Test second from bottom (-2)\nassert resolve_focus_slot(-2, 5) == 3\nassert resolve_focus_slot(-2, 3) == 1\nprint(\"Negative index focus tests passed!\")\n\nNegative index focus tests passed!\n\n\n\n# Test positive focus positions\nassert resolve_focus_slot(0, 5) == 0  # Top slot\nassert resolve_focus_slot(1, 5) == 1  # Second from top\nassert resolve_focus_slot(4, 5) == 4  # Last slot\nprint(\"Positive index focus tests passed!\")\n\nPositive index focus tests passed!\n\n\n\n# Test clamping for out-of-range values\nassert resolve_focus_slot(10, 5) == 4   # Clamped to last slot\nassert resolve_focus_slot(-10, 5) == 0  # Clamped to first slot\nprint(\"Clamping tests passed!\")\n\nClamping tests passed!",
    "crumbs": [
      "helpers",
      "Focus"
    ]
  },
  {
    "objectID": "helpers/focus.html#resolve_focus_slot",
    "href": "helpers/focus.html#resolve_focus_slot",
    "title": "Focus",
    "section": "",
    "text": "Converts the focus_position setting (which uses Python negative indexing convention) into an actual 0-indexed slot position within the viewport.\n\nsource\n\n\n\ndef resolve_focus_slot(\n    focus_position:Optional, # Slot offset (None=center, -1=bottom, 0=top)\n    visible_count:int, # Number of visible card slots\n)-&gt;int: # Resolved 0-indexed slot position\n\nResolve focus_position to an actual slot index within the viewport.\n\n# Test center focus (None)\nassert resolve_focus_slot(None, 5) == 2  # 5 cards -&gt; slot 2 (middle)\nassert resolve_focus_slot(None, 3) == 1  # 3 cards -&gt; slot 1\nassert resolve_focus_slot(None, 1) == 0  # 1 card -&gt; slot 0\nassert resolve_focus_slot(None, 7) == 3  # 7 cards -&gt; slot 3\nprint(\"Center focus tests passed!\")\n\nCenter focus tests passed!\n\n\n\n# Test bottom focus (-1)\nassert resolve_focus_slot(-1, 5) == 4  # Last slot\nassert resolve_focus_slot(-1, 3) == 2\nassert resolve_focus_slot(-1, 1) == 0\n\n# Test second from bottom (-2)\nassert resolve_focus_slot(-2, 5) == 3\nassert resolve_focus_slot(-2, 3) == 1\nprint(\"Negative index focus tests passed!\")\n\nNegative index focus tests passed!\n\n\n\n# Test positive focus positions\nassert resolve_focus_slot(0, 5) == 0  # Top slot\nassert resolve_focus_slot(1, 5) == 1  # Second from top\nassert resolve_focus_slot(4, 5) == 4  # Last slot\nprint(\"Positive index focus tests passed!\")\n\nPositive index focus tests passed!\n\n\n\n# Test clamping for out-of-range values\nassert resolve_focus_slot(10, 5) == 4   # Clamped to last slot\nassert resolve_focus_slot(-10, 5) == 0  # Clamped to first slot\nprint(\"Clamping tests passed!\")\n\nClamping tests passed!",
    "crumbs": [
      "helpers",
      "Focus"
    ]
  },
  {
    "objectID": "helpers/focus.html#calculate_viewport_window",
    "href": "helpers/focus.html#calculate_viewport_window",
    "title": "Focus",
    "section": "calculate_viewport_window",
    "text": "calculate_viewport_window\nDetermines which item indices are visible in each viewport slot. Returns None for slots that fall outside the items list (rendered as placeholders).\n\nsource\n\ncalculate_viewport_window\n\ndef calculate_viewport_window(\n    focused_index:int, # Index of the focused item\n    total_items:int, # Total number of items\n    visible_count:int, # Number of visible card slots\n    focus_position:Optional=None, # Focus slot (None=center)\n)-&gt;List: # Item indices for each slot (negative or &gt;= total_items for placeholders)\n\nCalculate which item indices should be visible in each viewport slot.\n\n# Test center focus with 5 visible cards, 20 items, focused on item 10\nwindow = calculate_viewport_window(10, 20, 5)\nassert window == [8, 9, 10, 11, 12]\nprint(\"Center viewport window test passed!\")\n\nCenter viewport window test passed!\n\n\n\n# Test center focus at beginning (negative indices for placeholders)\nwindow = calculate_viewport_window(0, 20, 5)\nassert window == [-2, -1, 0, 1, 2]\n\nwindow = calculate_viewport_window(1, 20, 5)\nassert window == [-1, 0, 1, 2, 3]\nprint(\"Beginning placeholder tests passed!\")\n\nBeginning placeholder tests passed!\n\n\n\n# Test center focus at end (indices &gt;= total_items for placeholders)\nwindow = calculate_viewport_window(19, 20, 5)\nassert window == [17, 18, 19, 20, 21]\n\nwindow = calculate_viewport_window(18, 20, 5)\nassert window == [16, 17, 18, 19, 20]\nprint(\"End placeholder tests passed!\")\n\nEnd placeholder tests passed!\n\n\n\n# Test bottom focus (-1): focused card at last slot\nwindow = calculate_viewport_window(5, 20, 5, focus_position=-1)\nassert window == [1, 2, 3, 4, 5]  # 4 context before, focused at end\n\n# At beginning with bottom focus (all before slots are placeholders)\nwindow = calculate_viewport_window(0, 20, 5, focus_position=-1)\nassert window == [-4, -3, -2, -1, 0]\nprint(\"Bottom focus tests passed!\")\n\nBottom focus tests passed!\n\n\n\n# Test top focus (0): focused card at first slot\nwindow = calculate_viewport_window(5, 20, 5, focus_position=0)\nassert window == [5, 6, 7, 8, 9]  # Focused first, 4 context after\n\n# At end with top focus (all after slots are placeholders)\nwindow = calculate_viewport_window(19, 20, 5, focus_position=0)\nassert window == [19, 20, 21, 22, 23]\nprint(\"Top focus tests passed!\")\n\nTop focus tests passed!\n\n\n\n# Test single card viewport\nwindow = calculate_viewport_window(5, 20, 1)\nassert window == [5]\nprint(\"Single card viewport test passed!\")\n\nSingle card viewport test passed!",
    "crumbs": [
      "helpers",
      "Focus"
    ]
  },
  {
    "objectID": "helpers/focus.html#render_focus_oob",
    "href": "helpers/focus.html#render_focus_oob",
    "title": "Focus",
    "section": "render_focus_oob",
    "text": "render_focus_oob\nRenders OOB hidden inputs to synchronize the focused index after HTMX swaps. One input is for keyboard navigation focus recovery, the other for HTMX form submissions.\n\nsource\n\nrender_focus_oob\n\ndef render_focus_oob(\n    focused_index:int, # The item index to focus\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    form_input_name:str='focused_index', # Field name for the form input\n)-&gt;Tuple: # Hidden inputs with OOB swap\n\nRender OOB hidden inputs to synchronize focus after HTMX swap.\n\n# Test render_focus_oob\nids = CardStackHtmlIds(prefix=\"cs0\")\nresult = render_focus_oob(5, ids)\nassert len(result) == 1\nassert result[0].id == \"cs0-focused-index\"\nassert result[0].name == \"focused_index\"\nassert result[0].value == \"5\"\nprint(\"render_focus_oob tests passed!\")\n\nrender_focus_oob tests passed!\n\n\n\n# Test with custom form input name\nresult = render_focus_oob(10, ids, form_input_name=\"segment_index\")\nassert result[0].name == \"segment_index\"\nassert result[0].value == \"10\"\nprint(\"Custom form input name test passed!\")\n\nCustom form input name test passed!",
    "crumbs": [
      "helpers",
      "Focus"
    ]
  },
  {
    "objectID": "js/navigation.html",
    "href": "js/navigation.html",
    "title": "JS: Page Navigation",
    "section": "",
    "text": "Generates functions that trigger HTMX navigation buttons for page jumps and first/last navigation. These are called by the keyboard navigation system’s KeyAction definitions.\n\nsource\n\n\n\ndef generate_page_nav_js(\n    button_ids:CardStackButtonIds, # Button IDs for navigation triggers\n)-&gt;str: # JavaScript code fragment for page navigation\n\nGenerate JS for page-based and first/last navigation functions.\n\n# Test page navigation JS generation\nbtn = CardStackButtonIds(prefix=\"cs0\")\njs = generate_page_nav_js(btn)\nassert btn.nav_page_up in js\nassert btn.nav_page_down in js\nassert btn.nav_first in js\nassert btn.nav_last in js\nassert \"ns.jumpPageUp\" in js\nassert \"ns.jumpPageDown\" in js\nassert \"ns.jumpToFirstItem\" in js\nassert \"ns.jumpToLastItem\" in js\nprint(\"Page navigation JS tests passed!\")\n\nPage navigation JS tests passed!",
    "crumbs": [
      "js",
      "JS: Page Navigation"
    ]
  },
  {
    "objectID": "js/navigation.html#generate_page_nav_js",
    "href": "js/navigation.html#generate_page_nav_js",
    "title": "JS: Page Navigation",
    "section": "",
    "text": "Generates functions that trigger HTMX navigation buttons for page jumps and first/last navigation. These are called by the keyboard navigation system’s KeyAction definitions.\n\nsource\n\n\n\ndef generate_page_nav_js(\n    button_ids:CardStackButtonIds, # Button IDs for navigation triggers\n)-&gt;str: # JavaScript code fragment for page navigation\n\nGenerate JS for page-based and first/last navigation functions.\n\n# Test page navigation JS generation\nbtn = CardStackButtonIds(prefix=\"cs0\")\njs = generate_page_nav_js(btn)\nassert btn.nav_page_up in js\nassert btn.nav_page_down in js\nassert btn.nav_first in js\nassert btn.nav_last in js\nassert \"ns.jumpPageUp\" in js\nassert \"ns.jumpPageDown\" in js\nassert \"ns.jumpToFirstItem\" in js\nassert \"ns.jumpToLastItem\" in js\nprint(\"Page navigation JS tests passed!\")\n\nPage navigation JS tests passed!",
    "crumbs": [
      "js",
      "JS: Page Navigation"
    ]
  },
  {
    "objectID": "js/auto_adjust.html",
    "href": "js/auto_adjust.html",
    "title": "JS: Auto Adjust",
    "section": "",
    "text": "Overflow-based feedback loop that dynamically determines how many cards fit in the viewport. Uses transparency-based growth validation: new cards are added with opacity: 0, measured for overflow, then revealed if they fit or reverted if they overflow. Shrink path removes overflowing cards reactively.\nDepends on _isAutoMode() and ns._autoUpdateCount() being defined earlier in the IIFE by the card count management fragment.\n\n# Test auto-adjust JS generation\nids = CardStackHtmlIds(prefix=\"cs0\")\nconfig = CardStackConfig(prefix=\"cs0\")\nurls = CardStackUrls(update_viewport=\"/cs/update_viewport\")\n\njs = _generate_auto_adjust_js(ids, config, urls)\nassert \"Auto Visible Count Adjustment\" in js\nassert \"_autoAdjusting\" in js\nassert \"_autoGrowing\" in js\nassert \"_preGrowthItemIds\" in js\nassert \"_preGrowthCount\" in js\nassert \"_snapshotItemIds\" in js\nassert \"_hideNewItems\" in js\nassert \"_revealNewItems\" in js\nassert \"_validateGrowth\" in js\nassert \"ns._runAutoAdjust\" in js\nassert \"ns.triggerAutoAdjust\" in js\nassert \"ns._cancelAutoGrowth\" in js\nassert \"ns._autoUpdateCount\" in js\n# Default focus_position=None → JS null, step=2\nassert \"const _AUTO_FOCUS_POS = null;\" in js\nassert \"(_AUTO_FOCUS_POS === null) ? 2 : 1\" in js\nprint(\"Auto-adjust JS basic tests passed!\")\n\nAuto-adjust JS basic tests passed!\n\n\n\n# Test focus_position parameter variations\njs_bottom = _generate_auto_adjust_js(ids, config, urls, focus_position=-1)\nassert \"const _AUTO_FOCUS_POS = -1;\" in js_bottom\n\njs_top = _generate_auto_adjust_js(ids, config, urls, focus_position=0)\nassert \"const _AUTO_FOCUS_POS = 0;\" in js_top\n\njs_custom = _generate_auto_adjust_js(ids, config, urls, focus_position=2)\nassert \"const _AUTO_FOCUS_POS = 2;\" in js_custom\nprint(\"Auto-adjust focus_position tests passed!\")\n\nAuto-adjust focus_position tests passed!",
    "crumbs": [
      "js",
      "JS: Auto Adjust"
    ]
  },
  {
    "objectID": "js/auto_adjust.html#generate_auto_adjust_js",
    "href": "js/auto_adjust.html#generate_auto_adjust_js",
    "title": "JS: Auto Adjust",
    "section": "",
    "text": "Overflow-based feedback loop that dynamically determines how many cards fit in the viewport. Uses transparency-based growth validation: new cards are added with opacity: 0, measured for overflow, then revealed if they fit or reverted if they overflow. Shrink path removes overflowing cards reactively.\nDepends on _isAutoMode() and ns._autoUpdateCount() being defined earlier in the IIFE by the card count management fragment.\n\n# Test auto-adjust JS generation\nids = CardStackHtmlIds(prefix=\"cs0\")\nconfig = CardStackConfig(prefix=\"cs0\")\nurls = CardStackUrls(update_viewport=\"/cs/update_viewport\")\n\njs = _generate_auto_adjust_js(ids, config, urls)\nassert \"Auto Visible Count Adjustment\" in js\nassert \"_autoAdjusting\" in js\nassert \"_autoGrowing\" in js\nassert \"_preGrowthItemIds\" in js\nassert \"_preGrowthCount\" in js\nassert \"_snapshotItemIds\" in js\nassert \"_hideNewItems\" in js\nassert \"_revealNewItems\" in js\nassert \"_validateGrowth\" in js\nassert \"ns._runAutoAdjust\" in js\nassert \"ns.triggerAutoAdjust\" in js\nassert \"ns._cancelAutoGrowth\" in js\nassert \"ns._autoUpdateCount\" in js\n# Default focus_position=None → JS null, step=2\nassert \"const _AUTO_FOCUS_POS = null;\" in js\nassert \"(_AUTO_FOCUS_POS === null) ? 2 : 1\" in js\nprint(\"Auto-adjust JS basic tests passed!\")\n\nAuto-adjust JS basic tests passed!\n\n\n\n# Test focus_position parameter variations\njs_bottom = _generate_auto_adjust_js(ids, config, urls, focus_position=-1)\nassert \"const _AUTO_FOCUS_POS = -1;\" in js_bottom\n\njs_top = _generate_auto_adjust_js(ids, config, urls, focus_position=0)\nassert \"const _AUTO_FOCUS_POS = 0;\" in js_top\n\njs_custom = _generate_auto_adjust_js(ids, config, urls, focus_position=2)\nassert \"const _AUTO_FOCUS_POS = 2;\" in js_custom\nprint(\"Auto-adjust focus_position tests passed!\")\n\nAuto-adjust focus_position tests passed!",
    "crumbs": [
      "js",
      "JS: Auto Adjust"
    ]
  },
  {
    "objectID": "js/core.html",
    "href": "js/core.html",
    "title": "JS: Core",
    "section": "",
    "text": "Applies all viewport settings (width, height, scroll, touch) then reveals the viewport using a double-RAF pattern. Also handles HTMX afterSettle events.",
    "crumbs": [
      "js",
      "JS: Core"
    ]
  },
  {
    "objectID": "js/core.html#master-coordinator",
    "href": "js/core.html#master-coordinator",
    "title": "JS: Core",
    "section": "",
    "text": "Applies all viewport settings (width, height, scroll, touch) then reveals the viewport using a double-RAF pattern. Also handles HTMX afterSettle events.",
    "crumbs": [
      "js",
      "JS: Core"
    ]
  },
  {
    "objectID": "js/core.html#global-callback-registration",
    "href": "js/core.html#global-callback-registration",
    "title": "JS: Core",
    "section": "Global Callback Registration",
    "text": "Global Callback Registration\nThe cjm-fasthtml-keyboard-navigation library looks up JS callbacks via window[action.jsCallback](). Since our functions live on the namespaced ns object, we register global wrappers that delegate to the namespace.\n\nsource\n\nglobal_callback_name\n\ndef global_callback_name(\n    prefix:str, # Card stack instance prefix\n    callback:str, # Base callback name (e.g., \"jumpPageUp\")\n)-&gt;str: # Global function name (e.g., \"cs0_jumpPageUp\")\n\nGenerate a prefix-unique global callback name for keyboard navigation.",
    "crumbs": [
      "js",
      "JS: Core"
    ]
  },
  {
    "objectID": "js/core.html#generate_card_stack_js",
    "href": "js/core.html#generate_card_stack_js",
    "title": "JS: Core",
    "section": "generate_card_stack_js",
    "text": "generate_card_stack_js\nThe main entry point that composes all JS fragments into a single namespaced IIFE. The consumer calls this once in their step renderer.\n\nsource\n\ngenerate_card_stack_js\n\ndef generate_card_stack_js(\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    button_ids:CardStackButtonIds, # Button IDs for keyboard triggers\n    config:CardStackConfig, # Card stack configuration\n    urls:CardStackUrls, # URL bundle for routing\n    container_id:str='', # Consumer's parent container ID (for height calc)\n    extra_scripts:Tuple=(), # Additional JS to include in the IIFE\n    focus_position:Optional=None, # Focus slot offset (None=center, -1=bottom, 0=top)\n)-&gt;Any: # Script element with all card stack JavaScript\n\nCompose all card stack JS into a single namespaced IIFE.\n\nfrom cjm_fasthtml_card_stack.core.config import _reset_prefix_counter\n\n\n# Test setup: shared fixtures for composition tests\n_reset_prefix_counter()\nconfig = CardStackConfig()\nids = CardStackHtmlIds(prefix=config.prefix)\nbtn = CardStackButtonIds(prefix=config.prefix)\nurls = CardStackUrls(\n    nav_up=\"/cs/nav_up\", nav_down=\"/cs/nav_down\",\n    nav_first=\"/cs/nav_first\", nav_last=\"/cs/nav_last\",\n    nav_page_up=\"/cs/nav_page_up\", nav_page_down=\"/cs/nav_page_down\",\n    nav_to_index=\"/cs/nav_to_index\",\n    update_viewport=\"/cs/update_viewport\",\n    save_width=\"/cs/save_width\", save_scale=\"/cs/save_scale\",\n)\n\nscript = generate_card_stack_js(ids, btn, config, urls, container_id=\"my-app\")\njs_text = script.children[0] if script.children else \"\"\n\n# Namespace setup\nassert \"window.cardStacks\" in js_text\nassert f\"'{config.prefix}'\" in js_text\n\n# All sections present in composed output\nfor section in [\n    \"Viewport Height\", \"Scroll Navigation\", \"Touch Navigation\",\n    \"Page Navigation\", \"Width Management\", \"Scale Management\",\n    \"Card Count Management\", \"Auto Visible Count Adjustment\",\n    \"Grid Template Management\", \"Global Keyboard Callbacks\",\n    \"Master Coordinator\", \"HTMX Event Listeners\",\n]:\n    assert section in js_text, f\"Missing section: {section}\"\n\n# Scroll-to-top before height calculation (fixes HTMX navigation scroll position issue)\nassert \"window.scrollTo(0, 0)\" in js_text, \"Missing scroll-to-top in initialization\"\n\nprint(\"Composition: namespace and section presence tests passed!\")\n\nComposition: namespace and section presence tests passed!\n\n\n\n# Test key namespace functions are exposed\nfor fn in [\n    \"ns.updateWidth\", \"ns.updateScale\", \"ns.updateCardCount\",\n    \"ns.handleCountChange\", \"ns._autoUpdateCount\", \"ns._runAutoAdjust\",\n    \"ns.triggerAutoAdjust\", \"ns.applyGridTemplate\", \"ns.jumpToFirstItem\",\n    \"ns.jumpToLastItem\", \"ns.applyAllViewportSettings\", \"ns.recalculateHeight\",\n    \"ns.decreaseWidth\", \"ns.increaseWidth\", \"ns.decreaseScale\", \"ns.increaseScale\",\n    \"ns._setupScrollNav\", \"ns._setupTouchNav\", \"ns.syncCountDropdown\",\n]:\n    assert fn in js_text, f\"Missing function: {fn}\"\n\n# Touch navigation (Pointer Events API)\nassert \"pointerdown\" in js_text\nassert \"pointermove\" in js_text\nassert \"setPointerCapture\" in js_text\nassert \"momentumTick\" in js_text\nprint(\"Composition: namespace function exposure tests passed!\")\n\nComposition: namespace function exposure tests passed!\n\n\n\n# Test auto-adjust and growth validation in composed output\nassert \"_autoAdjusting\" in js_text\nassert \"_autoGrowing\" in js_text\nassert \"_preGrowthItemIds\" in js_text\nassert \"_snapshotItemIds\" in js_text\nassert \"_hideNewItems\" in js_text\nassert \"_revealNewItems\" in js_text\nassert \"_validateGrowth\" in js_text\nassert \"ns._cancelAutoGrowth\" in js_text\nassert \"htmx:afterSwap\" in js_text\n\n# Card count uses swap:'none' for OOB updates\nassert \"swap: 'none',\\n                    values: { visible_count:\" in js_text\nprint(\"Composition: auto-adjust and growth validation tests passed!\")\n\nComposition: auto-adjust and growth validation tests passed!\n\n\n\n# Test global callback wrappers and HTMX listener cleanup\nprefix = config.prefix\nfor cb in [\"jumpPageUp\", \"jumpToFirstItem\", \"decreaseWidth\", \"increaseWidth\",\n           \"decreaseScale\", \"increaseScale\"]:\n    assert f\"window['{prefix}_{cb}']\" in js_text, f\"Missing global callback: {cb}\"\n\n# HTMX listeners use remove-and-replace pattern\nhandler_key = f\"_csHandlers_{config.prefix.replace('-', '_')}\"\nassert f\"window.{handler_key}\" in js_text\nassert \"removeEventListener\" in js_text\nassert \"_afterSwapHandler\" in js_text\nassert \"_afterSettleHandler\" in js_text\nprint(\"Composition: global callbacks and HTMX listener tests passed!\")\n\nComposition: global callbacks and HTMX listener tests passed!\n\n\n\n# Test focus_position parameter produces correct JS literals\n_reset_prefix_counter()\n_fp_config = CardStackConfig()\n_fp_ids = CardStackHtmlIds(prefix=_fp_config.prefix)\n_fp_btn = CardStackButtonIds(prefix=_fp_config.prefix)\n\n# Default (None) → JS null (center focus)\n_fp_script = generate_card_stack_js(_fp_ids, _fp_btn, _fp_config, urls)\n_fp_js = _fp_script.children[0] if _fp_script.children else \"\"\nassert \"const focusPosRaw = null;\" in _fp_js\n\n# Bottom focus (-1)\n_fp_script_bottom = generate_card_stack_js(_fp_ids, _fp_btn, _fp_config, urls, focus_position=-1)\n_fp_js_bottom = _fp_script_bottom.children[0] if _fp_script_bottom.children else \"\"\nassert \"const focusPosRaw = -1;\" in _fp_js_bottom\n\n# Top focus (0)\n_fp_script_top = generate_card_stack_js(_fp_ids, _fp_btn, _fp_config, urls, focus_position=0)\n_fp_js_top = _fp_script_top.children[0] if _fp_script_top.children else \"\"\nassert \"const focusPosRaw = 0;\" in _fp_js_top\n\nprint(\"Focus position parameter tests passed!\")\n\nFocus position parameter tests passed!\n\n\n\n# Test extra_scripts injection\n_reset_prefix_counter()\nconfig2 = CardStackConfig()\nids2 = CardStackHtmlIds(prefix=config2.prefix)\nbtn2 = CardStackButtonIds(prefix=config2.prefix)\n\nscript2 = generate_card_stack_js(\n    ids2, btn2, config2, urls,\n    extra_scripts=(\"ns.customFunction = function() { console.log('custom'); };\",)\n)\njs2 = script2.children[0] if script2.children else \"\"\nassert \"ns.customFunction\" in js2\nprint(\"Extra scripts injection test passed!\")\n\nExtra scripts injection test passed!\n\n\n\n# Test with disable_scroll_in_modes\nconfig3 = CardStackConfig(prefix=\"split-test\", disable_scroll_in_modes=(\"split\",))\nids3 = CardStackHtmlIds(prefix=config3.prefix)\nbtn3 = CardStackButtonIds(prefix=config3.prefix)\n\nscript3 = generate_card_stack_js(ids3, btn3, config3, urls)\njs3 = script3.children[0] if script3.children else \"\"\nassert \"isScrollDisabled\" in js3\nassert \"isTouchDisabled\" in js3\nassert \"'split'\" in js3\nprint(\"Scroll/touch mode disabling in composed JS test passed!\")\n\n# Test with auto_visible_count=False excludes auto-adjust and growth validation\nconfig4 = CardStackConfig(prefix=\"no-auto\", auto_visible_count=False)\nids4 = CardStackHtmlIds(prefix=config4.prefix)\nbtn4 = CardStackButtonIds(prefix=config4.prefix)\n\nscript4 = generate_card_stack_js(ids4, btn4, config4, urls)\njs4 = script4.children[0] if script4.children else \"\"\nassert \"Auto Visible Count Adjustment\" not in js4\nassert \"_snapshotItemIds\" not in js4\n# assert \"_hideNewItems\" not in js4\nassert \"_revealNewItems\" not in js4\n# But handleCountChange and _isAutoMode are still in count management\nassert \"ns.handleCountChange\" in js4\nprint(\"auto_visible_count=False exclusion test passed!\")\n\nScroll/touch mode disabling in composed JS test passed!\nauto_visible_count=False exclusion test passed!",
    "crumbs": [
      "js",
      "JS: Core"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "cjm-fasthtml-card-stack",
    "section": "",
    "text": "pip install cjm_fasthtml_card_stack",
    "crumbs": [
      "cjm-fasthtml-card-stack"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "cjm-fasthtml-card-stack",
    "section": "",
    "text": "pip install cjm_fasthtml_card_stack",
    "crumbs": [
      "cjm-fasthtml-card-stack"
    ]
  },
  {
    "objectID": "index.html#project-structure",
    "href": "index.html#project-structure",
    "title": "cjm-fasthtml-card-stack",
    "section": "Project Structure",
    "text": "Project Structure\nnbs/\n├── components/ (4)\n│   ├── controls.ipynb  # Width slider, scale slider, and card count selector components.\n│   ├── progress.ipynb  # Progress indicator showing the current position within the card stack.\n│   ├── states.ipynb    # Loading, empty, and placeholder card components for the card stack viewport.\n│   └── viewport.ipynb  # Card stack viewport with 3-section CSS Grid layout, slot rendering,\n├── core/ (5)\n│   ├── button_ids.ipynb  # Prefix-based IDs for hidden keyboard action buttons.\n│   ├── config.ipynb      # Configuration dataclasses for card stack initialization and visual styling.\n│   ├── constants.ipynb   # CSS class constants, type aliases, and default values for the card stack library.\n│   ├── html_ids.ipynb    # Prefix-based HTML ID generator for card stack DOM elements.\n│   └── models.ipynb      # Core dataclasses for card stack state, render context, and URL routing.\n├── helpers/ (1)\n│   └── focus.ipynb  # Focus position resolution, viewport window calculation, and OOB focus sync.\n├── js/ (7)\n│   ├── auto_adjust.ipynb  # JavaScript generator for automatic visible card count adjustment.\n│   ├── controls.ipynb     # JavaScript generators for width, scale, and card count management.\n│   ├── core.ipynb         # Master composer for card stack JavaScript. Combines viewport height,\n│   ├── navigation.ipynb   # JavaScript generator for page jump and first/last navigation helpers.\n│   ├── scroll.ipynb       # JavaScript generator for scroll-to-nav conversion.\n│   ├── touch.ipynb        # JavaScript generator for touch-to-nav conversion: swipe, drag,\n│   └── viewport.ipynb     # JavaScript generator for dynamic viewport height calculation.\n├── keyboard/ (1)\n│   └── actions.ipynb  # Keyboard navigation focus zone and action factories for the card stack.\n└── routes/ (2)\n    ├── handlers.ipynb  # Response builder functions for card stack operations (Tier 1 API).\n    └── router.ipynb    # Convenience router factory that wires up standard card stack routes (Tier 2 API).\nTotal: 20 notebooks across 6 directories",
    "crumbs": [
      "cjm-fasthtml-card-stack"
    ]
  },
  {
    "objectID": "index.html#module-dependencies",
    "href": "index.html#module-dependencies",
    "title": "cjm-fasthtml-card-stack",
    "section": "Module Dependencies",
    "text": "Module Dependencies\ngraph LR\n    components_controls[components.controls&lt;br/&gt;Controls]\n    components_progress[components.progress&lt;br/&gt;Progress]\n    components_states[components.states&lt;br/&gt;States]\n    components_viewport[components.viewport&lt;br/&gt;Viewport]\n    core_button_ids[core.button_ids&lt;br/&gt;Button IDs]\n    core_config[core.config&lt;br/&gt;Config]\n    core_constants[core.constants&lt;br/&gt;Constants]\n    core_html_ids[core.html_ids&lt;br/&gt;HTML IDs]\n    core_models[core.models&lt;br/&gt;Models]\n    helpers_focus[helpers.focus&lt;br/&gt;Focus]\n    js_auto_adjust[js.auto_adjust&lt;br/&gt;JS: Auto Adjust]\n    js_controls[js.controls&lt;br/&gt;JS: Controls]\n    js_core[js.core&lt;br/&gt;JS: Core]\n    js_navigation[js.navigation&lt;br/&gt;JS: Page Navigation]\n    js_scroll[js.scroll&lt;br/&gt;JS: Scroll Navigation]\n    js_touch[js.touch&lt;br/&gt;JS: Touch Navigation]\n    js_viewport[js.viewport&lt;br/&gt;JS: Viewport Height]\n    keyboard_actions[keyboard.actions&lt;br/&gt;Actions]\n    routes_handlers[routes.handlers&lt;br/&gt;Handlers]\n    routes_router[routes.router&lt;br/&gt;Router]\n\n    components_controls --&gt; core_html_ids\n    components_controls --&gt; core_config\n    components_progress --&gt; core_html_ids\n    components_states --&gt; core_html_ids\n    components_viewport --&gt; core_models\n    components_viewport --&gt; core_html_ids\n    components_viewport --&gt; helpers_focus\n    components_viewport --&gt; core_config\n    components_viewport --&gt; components_states\n    components_viewport --&gt; core_constants\n    helpers_focus --&gt; core_html_ids\n    js_auto_adjust --&gt; core_models\n    js_auto_adjust --&gt; core_html_ids\n    js_auto_adjust --&gt; core_constants\n    js_auto_adjust --&gt; core_config\n    js_controls --&gt; core_constants\n    js_controls --&gt; core_models\n    js_controls --&gt; core_html_ids\n    js_controls --&gt; core_config\n    js_core --&gt; core_html_ids\n    js_core --&gt; core_config\n    js_core --&gt; js_controls\n    js_core --&gt; core_constants\n    js_core --&gt; js_navigation\n    js_core --&gt; core_models\n    js_core --&gt; core_button_ids\n    js_core --&gt; js_auto_adjust\n    js_core --&gt; js_viewport\n    js_core --&gt; js_touch\n    js_core --&gt; js_scroll\n    js_navigation --&gt; core_button_ids\n    js_scroll --&gt; core_constants\n    js_scroll --&gt; core_html_ids\n    js_scroll --&gt; core_button_ids\n    js_touch --&gt; core_constants\n    js_touch --&gt; core_html_ids\n    js_touch --&gt; core_button_ids\n    js_viewport --&gt; core_html_ids\n    keyboard_actions --&gt; core_html_ids\n    keyboard_actions --&gt; core_config\n    keyboard_actions --&gt; core_button_ids\n    keyboard_actions --&gt; js_core\n    keyboard_actions --&gt; core_models\n    routes_handlers --&gt; core_models\n    routes_handlers --&gt; core_html_ids\n    routes_handlers --&gt; core_config\n    routes_handlers --&gt; components_progress\n    routes_handlers --&gt; helpers_focus\n    routes_handlers --&gt; components_viewport\n    routes_router --&gt; core_models\n    routes_router --&gt; core_html_ids\n    routes_router --&gt; core_config\n    routes_router --&gt; routes_handlers\n53 cross-module dependencies detected",
    "crumbs": [
      "cjm-fasthtml-card-stack"
    ]
  },
  {
    "objectID": "index.html#cli-reference",
    "href": "index.html#cli-reference",
    "title": "cjm-fasthtml-card-stack",
    "section": "CLI Reference",
    "text": "CLI Reference\nNo CLI commands found in this project.",
    "crumbs": [
      "cjm-fasthtml-card-stack"
    ]
  },
  {
    "objectID": "index.html#module-overview",
    "href": "index.html#module-overview",
    "title": "cjm-fasthtml-card-stack",
    "section": "Module Overview",
    "text": "Module Overview\nDetailed documentation for each module in the project:\n\nActions (actions.ipynb)\n\nKeyboard navigation focus zone and action factories for the card stack.\n\n\nImport\nfrom cjm_fasthtml_card_stack.keyboard.actions import (\n    create_card_stack_focus_zone,\n    create_card_stack_nav_actions,\n    build_card_stack_url_map,\n    render_card_stack_action_buttons\n)\n\n\nFunctions\ndef create_card_stack_focus_zone(\n    ids: CardStackHtmlIds,  # HTML IDs for this card stack instance\n    on_focus_change: Optional[str] = None,  # JS callback name on focus change\n    hidden_input_prefix: Optional[str] = None,  # Prefix for keyboard nav hidden inputs\n    data_attributes: Tuple[str, ...] = (),  # Data attributes to track on focused items\n) -&gt; FocusZone:  # Configured focus zone for the card stack\n    \"Create a focus zone for a card stack viewport.\"\ndef create_card_stack_nav_actions(\n    zone_id: str,  # Focus zone ID to restrict actions to\n    button_ids: CardStackButtonIds,  # Button IDs for HTMX triggers\n    config: CardStackConfig,  # Config (for prefix-unique callback names)\n    disable_in_modes: Tuple[str, ...] = (),  # Mode names that disable navigation\n) -&gt; Tuple[KeyAction, ...]:  # Standard card stack navigation actions\n    \"Create standard keyboard navigation actions for a card stack.\"\ndef build_card_stack_url_map(\n    button_ids: CardStackButtonIds,  # Button IDs for this card stack instance\n    urls: CardStackUrls,  # URL bundle for routing\n) -&gt; Dict[str, str]:  # Mapping of button ID -&gt; route URL\n    \"\"\"\n    Build url_map for render_keyboard_system with all card stack navigation buttons.\n    \n    Returns a dict mapping button IDs to URLs for all navigation actions:\n    nav_up, nav_down, nav_first, nav_last, nav_page_up, nav_page_down.\n    \n    Merge with consumer's own action URLs when building the keyboard system:\n        url_map = {**build_card_stack_url_map(btn_ids, urls), **my_action_urls}\n    \"\"\"\ndef render_card_stack_action_buttons(\n    button_ids: CardStackButtonIds,  # Button IDs for this card stack instance\n    urls: CardStackUrls,  # URL bundle for routing\n    ids: CardStackHtmlIds,  # HTML IDs (for hx-include of focused_index_input)\n) -&gt; 'FT':  # Div containing hidden action buttons\n    \"\"\"\n    Render hidden HTMX buttons for JS-callback-triggered navigation actions.\n    \n    Creates buttons for: page_up, page_down, first, last.\n    These are clicked programmatically by the card stack's JS functions.\n    Must be included in the DOM alongside the keyboard system's own buttons.\n    \"\"\"\n\n\n\nJS: Auto Adjust (auto_adjust.ipynb)\n\nJavaScript generator for automatic visible card count adjustment.\n\n\nImport\nfrom cjm_fasthtml_card_stack.js.auto_adjust import *\n\n\nFunctions\ndef _generate_auto_adjust_js(\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    config: CardStackConfig,  # Config for auto mode check\n    urls: CardStackUrls,  # URL bundle (update_viewport)\n    focus_position: Optional[int] = None,  # Focus slot offset (None=center, -1=bottom, 0=top)\n) -&gt; str:  # JS code fragment for auto visible count adjustment\n    \"Generate JS for automatic visible count adjustment based on overflow detection.\"\n\n\n\nButton IDs (button_ids.ipynb)\n\nPrefix-based IDs for hidden keyboard action buttons.\n\n\nImport\nfrom cjm_fasthtml_card_stack.core.button_ids import (\n    CardStackButtonIds\n)\n\n\nClasses\n@dataclass\nclass CardStackButtonIds:\n    \"Prefix-based IDs for hidden keyboard action buttons.\"\n    \n    prefix: str  # ID prefix for this card stack instance\n    \n    def nav_up(self) -&gt; str:  # Navigate to previous item\n            \"\"\"Navigate up button.\"\"\"\n            return f\"{self.prefix}-btn-nav-up\"\n    \n        @property\n        def nav_down(self) -&gt; str:  # Navigate to next item\n        \"Navigate up button.\"\n    \n    def nav_down(self) -&gt; str:  # Navigate to next item\n            \"\"\"Navigate down button.\"\"\"\n            return f\"{self.prefix}-btn-nav-down\"\n    \n        @property\n        def nav_first(self) -&gt; str:  # Navigate to first item\n        \"Navigate down button.\"\n    \n    def nav_first(self) -&gt; str:  # Navigate to first item\n            \"\"\"Navigate to first item button.\"\"\"\n            return f\"{self.prefix}-btn-nav-first\"\n    \n        @property\n        def nav_last(self) -&gt; str:  # Navigate to last item\n        \"Navigate to first item button.\"\n    \n    def nav_last(self) -&gt; str:  # Navigate to last item\n            \"\"\"Navigate to last item button.\"\"\"\n            return f\"{self.prefix}-btn-nav-last\"\n    \n        @property\n        def nav_page_up(self) -&gt; str:  # Page jump up\n        \"Navigate to last item button.\"\n    \n    def nav_page_up(self) -&gt; str:  # Page jump up\n            \"\"\"Page up button.\"\"\"\n            return f\"{self.prefix}-btn-nav-page-up\"\n    \n        @property\n        def nav_page_down(self) -&gt; str:  # Page jump down\n        \"Page up button.\"\n    \n    def nav_page_down(self) -&gt; str:  # Page jump down\n            \"\"\"Page down button.\"\"\"\n            return f\"{self.prefix}-btn-nav-page-down\"\n    \n        # --- Viewport control buttons ---\n    \n        @property\n        def width_narrow(self) -&gt; str:  # Decrease viewport width\n        \"Page down button.\"\n    \n    def width_narrow(self) -&gt; str:  # Decrease viewport width\n            \"\"\"Narrow viewport button.\"\"\"\n            return f\"{self.prefix}-btn-width-narrow\"\n    \n        @property\n        def width_widen(self) -&gt; str:  # Increase viewport width\n        \"Narrow viewport button.\"\n    \n    def width_widen(self) -&gt; str:  # Increase viewport width\n            \"\"\"Widen viewport button.\"\"\"\n            return f\"{self.prefix}-btn-width-widen\"\n    \n        @property\n        def scale_decrease(self) -&gt; str:  # Decrease content scale\n        \"Widen viewport button.\"\n    \n    def scale_decrease(self) -&gt; str:  # Decrease content scale\n            \"\"\"Decrease scale button.\"\"\"\n            return f\"{self.prefix}-btn-scale-decrease\"\n    \n        @property\n        def scale_increase(self) -&gt; str:  # Increase content scale\n        \"Decrease scale button.\"\n    \n    def scale_increase(self) -&gt; str:  # Increase content scale\n        \"Increase scale button.\"\n\n\n\nConfig (config.ipynb)\n\nConfiguration dataclasses for card stack initialization and visual styling.\n\n\nImport\nfrom cjm_fasthtml_card_stack.core.config import (\n    CardStackStyleConfig,\n    CardStackConfig\n)\n\n\nFunctions\ndef _auto_prefix() -&gt; str:  # Unique prefix string (e.g., \"cs0\", \"cs1\")\n    \"\"\"Generate an auto-incrementing unique prefix.\"\"\"\n    global _prefix_counter\n    p = f\"cs{_prefix_counter}\"\n    _prefix_counter += 1\n    return p\n\ndef _reset_prefix_counter() -&gt; None\n    \"Generate an auto-incrementing unique prefix.\"\ndef _reset_prefix_counter() -&gt; None\n    \"Reset the prefix counter (for testing only).\"\n\n\nClasses\n@dataclass\nclass CardStackStyleConfig:\n    \"Visual styling for a card stack instance.\"\n    \n    section_gap: str = '1rem'  # Gap between cards in each section\n    slot_padding: str = '0.25rem'  # Padding around context card content\n    viewport_padding_x: str = '0.5rem'  # Horizontal outer container padding\n    viewport_padding_y: str = '0.5rem'  # Vertical outer container padding\n    focus_padding_x: str = '0.5rem'  # Horizontal focused section padding\n    focus_padding_b: str = '1rem'  # Bottom focused section padding\n    focus_ring: str = _DEFAULT_FOCUS_RING  # Ring classes for focused card\n    focus_shadow: str = _DEFAULT_FOCUS_SHADOW  # Shadow classes for focused card\n    focus_border_radius: str = _DEFAULT_FOCUS_BORDER_RADIUS  # Border radius class for focused card\n    \n    def css_vars_style(\n            self,\n            prefix: str,  # Card stack instance prefix\n        ) -&gt; str:  # Inline style string with CSS custom property declarations\n        \"Generate CSS custom property declarations as an inline style string.\"\n@dataclass\nclass CardStackConfig:\n    \"Initialization-time settings for a card stack instance.\"\n    \n    prefix: str = field(...)  # HTML ID prefix (auto-generated if omitted)\n    visible_count_options: Tuple[int, ...] = (1, 3, 5, 7, 9)  # Choices for card count dropdown\n    auto_visible_count: bool = True  # Whether \"Auto\" option appears in card count dropdown\n    card_width_min: int = 30  # Width slider minimum (rem)\n    card_width_max: int = 120  # Width slider maximum (rem)\n    card_width_step: int = 5  # Width slider step (rem)\n    card_scale_min: int = 50  # Scale slider minimum (%)\n    card_scale_max: int = 200  # Scale slider maximum (%)\n    card_scale_step: int = 10  # Scale slider step (%)\n    click_to_focus: bool = False  # Whether context cards get transparent click overlay\n    disable_scroll_in_modes: Tuple[str, ...] = ()  # Mode names where scroll-to-nav is suppressed\n    style: CardStackStyleConfig = field(...)  # Visual styling config\n\n\nVariables\n_prefix_counter: int = 0\n_DEFAULT_FOCUS_RING: str\n_DEFAULT_FOCUS_SHADOW: str\n_DEFAULT_FOCUS_BORDER_RADIUS: str\n\n\n\nConstants (constants.ipynb)\n\nCSS class constants, type aliases, and default values for the card stack library.\n\n\nImport\nfrom cjm_fasthtml_card_stack.core.constants import (\n    CardRole,\n    SCROLL_THRESHOLD,\n    NAVIGATION_COOLDOWN,\n    TRACKPAD_COOLDOWN,\n    TOUCH_SWIPE_THRESHOLD,\n    TOUCH_MOMENTUM_MIN_VELOCITY,\n    TOUCH_MOMENTUM_FRICTION,\n    TOUCH_PINCH_THRESHOLD,\n    TOUCH_VELOCITY_SAMPLES,\n    DEFAULT_VISIBLE_COUNT,\n    DEFAULT_CARD_WIDTH,\n    DEFAULT_CARD_SCALE,\n    width_storage_key,\n    scale_storage_key,\n    card_count_storage_key,\n    auto_count_storage_key\n)\n\n\nFunctions\ndef width_storage_key(\n    prefix: str  # Card stack instance prefix\n) -&gt; str:  # localStorage key for card width\n    \"Generate localStorage key for card width.\"\ndef scale_storage_key(\n    prefix: str  # Card stack instance prefix\n) -&gt; str:  # localStorage key for card scale\n    \"Generate localStorage key for card scale.\"\ndef card_count_storage_key(\n    prefix: str  # Card stack instance prefix\n) -&gt; str:  # localStorage key for card count\n    \"Generate localStorage key for card count.\"\ndef auto_count_storage_key(\n    prefix: str  # Card stack instance prefix\n) -&gt; str:  # localStorage key for auto card count mode\n    \"Generate localStorage key for auto card count mode.\"\n\n\nVariables\nSCROLL_THRESHOLD: int = 1\nNAVIGATION_COOLDOWN: int = 100\nTRACKPAD_COOLDOWN: int = 250\nTOUCH_SWIPE_THRESHOLD: int = 30\nTOUCH_MOMENTUM_MIN_VELOCITY: float = 0.5\nTOUCH_MOMENTUM_FRICTION: float = 0.95\nTOUCH_PINCH_THRESHOLD: int = 30\nTOUCH_VELOCITY_SAMPLES: int = 5\nDEFAULT_VISIBLE_COUNT: int = 3\nDEFAULT_CARD_WIDTH: int = 80\nDEFAULT_CARD_SCALE: int = 100\n\n\n\nControls (controls.ipynb)\n\nWidth slider, scale slider, and card count selector components.\n\n\nImport\nfrom cjm_fasthtml_card_stack.components.controls import (\n    render_width_slider,\n    render_scale_slider,\n    render_card_count_select\n)\n\n\nFunctions\ndef render_width_slider(\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    card_width: int = 80,  # Current card width in rem\n) -&gt; Any:  # Width slider component\n    \"Render the card stack width slider control.\"\ndef render_scale_slider(\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    card_scale: int = 100,  # Current scale percentage\n) -&gt; Any:  # Scale slider component\n    \"Render the card stack scale slider control.\"\ndef render_card_count_select(\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    current_count: int = 3,  # Currently selected card count\n    is_auto_mode: bool = False,  # Whether auto-adjust mode is active\n) -&gt; Any:  # Card count dropdown component\n    \"Render the card count dropdown selector.\"\n\n\n\nJS: Controls (controls.ipynb)\n\nJavaScript generators for width, scale, and card count management.\n\n\nImport\nfrom cjm_fasthtml_card_stack.js.controls import *\n\n\nFunctions\ndef _generate_width_mgmt_js(\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    config: CardStackConfig,  # Config with slider bounds\n    urls: CardStackUrls,  # URL bundle (save_width)\n) -&gt; str:  # JS code fragment for width management\n    \"Generate JS for width slider management.\"\ndef _generate_scale_mgmt_js(\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    config: CardStackConfig,  # Config with slider bounds\n    urls: CardStackUrls,  # URL bundle (save_scale)\n) -&gt; str:  # JS code fragment for scale management\n    \"Generate JS for scale slider management.\"\ndef _generate_card_count_mgmt_js(\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    config: CardStackConfig,  # Config with count options\n    urls: CardStackUrls,  # URL bundle (update_viewport)\n) -&gt; str:  # JS code fragment for card count management\n    \"Generate JS for card count selector management.\"\n\n\n\nJS: Core (core.ipynb)\n\nMaster composer for card stack JavaScript. Combines viewport height,\n\n\nImport\nfrom cjm_fasthtml_card_stack.js.core import (\n    global_callback_name,\n    generate_card_stack_js\n)\n\n\nFunctions\ndef _generate_coordinator_js(\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    config: CardStackConfig,  # Config for prefix-unique listener guards\n    focus_position: Optional[int] = None,  # Focus slot offset (None=center, -1=bottom, 0=top)\n) -&gt; str:  # JS code fragment for master coordinator\n    \"Generate JS for the master coordinator and HTMX listener.\"\ndef global_callback_name(\n    prefix: str,  # Card stack instance prefix\n    callback: str,  # Base callback name (e.g., \"jumpPageUp\")\n) -&gt; str:  # Global function name (e.g., \"cs0_jumpPageUp\")\n    \"Generate a prefix-unique global callback name for keyboard navigation.\"\ndef _generate_global_callbacks_js(\n    config: CardStackConfig,  # Config with prefix\n) -&gt; str:  # JS code fragment registering global wrappers\n    \"Register global wrappers for keyboard navigation system.\"\ndef generate_card_stack_js(\n    \"Compose all card stack JS into a single namespaced IIFE.\"\n\n\nVariables\n_GLOBAL_CALLBACKS\n\n\n\nFocus (focus.ipynb)\n\nFocus position resolution, viewport window calculation, and OOB focus sync.\n\n\nImport\nfrom cjm_fasthtml_card_stack.helpers.focus import (\n    resolve_focus_slot,\n    calculate_viewport_window,\n    render_focus_oob\n)\n\n\nFunctions\ndef resolve_focus_slot(\n    focus_position: Optional[int],  # Slot offset (None=center, -1=bottom, 0=top)\n    visible_count: int,  # Number of visible card slots\n) -&gt; int:  # Resolved 0-indexed slot position\n    \"Resolve focus_position to an actual slot index within the viewport.\"\ndef calculate_viewport_window(\n    focused_index: int,  # Index of the focused item\n    total_items: int,  # Total number of items\n    visible_count: int,  # Number of visible card slots\n    focus_position: Optional[int] = None,  # Focus slot (None=center)\n) -&gt; List[int]:  # Item indices for each slot (negative or &gt;= total_items for placeholders)\n    \"Calculate which item indices should be visible in each viewport slot.\"\ndef render_focus_oob(\n    focused_index: int,  # The item index to focus\n    ids: CardStackHtmlIds,  # HTML IDs for this card stack instance\n    form_input_name: str = \"focused_index\",  # Field name for the form input\n) -&gt; Tuple[Hidden, ...]:  # Hidden inputs with OOB swap\n    \"Render OOB hidden inputs to synchronize focus after HTMX swap.\"\n\n\n\nHandlers (handlers.ipynb)\n\nResponse builder functions for card stack operations (Tier 1 API).\n\n\nImport\nfrom cjm_fasthtml_card_stack.routes.handlers import (\n    build_slots_response,\n    build_nav_response,\n    card_stack_navigate,\n    card_stack_navigate_to_index,\n    card_stack_update_viewport,\n    card_stack_save_width,\n    card_stack_save_scale\n)\n\n\nFunctions\ndef build_slots_response(\n    card_items: List[Any],  # All data items\n    state: CardStackState,  # Current card stack state\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    urls: CardStackUrls,  # URL bundle for navigation\n    render_card: Callable,  # Card renderer callback\n) -&gt; List[Any]:  # OOB slot elements (3 viewport sections)\n    \"Build OOB slot updates for the viewport sections only.\"\ndef build_nav_response(\n    card_items: List[Any],  # All data items\n    state: CardStackState,  # Current card stack state\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    urls: CardStackUrls,  # URL bundle for navigation\n    render_card: Callable,  # Card renderer callback\n    progress_label: str = \"Item\",  # Label for progress indicator\n) -&gt; Tuple:  # OOB elements (slots + progress + focus)\n    \"Build full OOB response for navigation: slots + progress + focus inputs.\"\ndef card_stack_navigate(\n    direction: str,  # \"up\", \"down\", \"first\", \"last\", \"page_up\", \"page_down\"\n    card_items: List[Any],  # All data items\n    state: CardStackState,  # Current card stack state (mutated in place)\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    urls: CardStackUrls,  # URL bundle for navigation\n    render_card: Callable,  # Card renderer callback\n    progress_label: str = \"Item\",  # Label for progress indicator\n) -&gt; Tuple:  # OOB elements (slots + progress + focus)\n    \"Navigate to a different item. Mutates state.focused_index in place.\"\ndef card_stack_navigate_to_index(\n    target_index: int,  # Target item index to navigate to\n    card_items: List[Any],  # All data items\n    state: CardStackState,  # Current card stack state (mutated in place)\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    urls: CardStackUrls,  # URL bundle for navigation\n    render_card: Callable,  # Card renderer callback\n    progress_label: str = \"Item\",  # Label for progress indicator\n) -&gt; Tuple:  # OOB elements (slots + progress + focus)\n    \"Navigate to a specific item index. Mutates state.focused_index in place.\"\ndef card_stack_update_viewport(\n    visible_count: int,  # New number of visible cards\n    card_items: List[Any],  # All data items\n    state: CardStackState,  # Current card stack state (mutated in place)\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    urls: CardStackUrls,  # URL bundle for navigation\n    render_card: Callable,  # Card renderer callback\n) -&gt; Tuple:  # OOB section elements (3 viewport sections)\n    \"Update viewport with new card count via OOB section swaps. Mutates state.visible_count in place.\"\ndef card_stack_save_width(\n    state: CardStackState,  # Current card stack state (mutated in place)\n    card_width: int,  # Card stack width in rem\n    config: CardStackConfig,  # Card stack configuration (for clamping bounds)\n) -&gt; None:  # No response (swap=none on client)\n    \"Save card stack width. Mutates state.card_width in place.\"\ndef card_stack_save_scale(\n    state: CardStackState,  # Current card stack state (mutated in place)\n    card_scale: int,  # Card stack scale percentage\n    config: CardStackConfig,  # Card stack configuration (for clamping bounds)\n) -&gt; None:  # No response (swap=none on client)\n    \"Save card stack scale. Mutates state.card_scale in place.\"\n\n\n\nHTML IDs (html_ids.ipynb)\n\nPrefix-based HTML ID generator for card stack DOM elements.\n\n\nImport\nfrom cjm_fasthtml_card_stack.core.html_ids import (\n    CardStackHtmlIds\n)\n\n\nClasses\n@dataclass\nclass CardStackHtmlIds:\n    \"Prefix-based HTML ID generator for card stack DOM elements.\"\n    \n    prefix: str  # ID prefix for this card stack instance\n    \n    def card_stack(self) -&gt; str:  # Full-width scroll capture container\n            \"\"\"Outer card stack container.\"\"\"\n            return f\"{self.prefix}-card-stack\"\n    \n        @property\n        def card_stack_inner(self) -&gt; str:  # Width-constrained CSS Grid container\n        \"Outer card stack container.\"\n    \n    def card_stack_inner(self) -&gt; str:  # Width-constrained CSS Grid container\n            \"\"\"Inner grid container for 3-section layout.\"\"\"\n            return f\"{self.prefix}-card-stack-inner\"\n    \n        @property\n        def card_stack_empty(self) -&gt; str:  # Empty state placeholder\n        \"Inner grid container for 3-section layout.\"\n    \n    def card_stack_empty(self) -&gt; str:  # Empty state placeholder\n            \"\"\"Empty state container.\"\"\"\n            return f\"{self.prefix}-card-stack-empty\"\n    \n        # --- Viewport sections ---\n    \n        @property\n        def viewport_section_before(self) -&gt; str:  # Cards before focused (1fr, justify-end)\n        \"Empty state container.\"\n    \n    def viewport_section_before(self) -&gt; str:  # Cards before focused (1fr, justify-end)\n            \"\"\"Viewport section for context cards before focused card.\"\"\"\n            return f\"{self.prefix}-viewport-section-before\"\n    \n        @property\n        def viewport_section_focused(self) -&gt; str:  # Focused card (auto)\n        \"Viewport section for context cards before focused card.\"\n    \n    def viewport_section_focused(self) -&gt; str:  # Focused card (auto)\n            \"\"\"Viewport section for the focused card.\"\"\"\n            return f\"{self.prefix}-viewport-section-focused\"\n    \n        @property\n        def viewport_section_after(self) -&gt; str:  # Cards after focused (1fr, justify-start)\n        \"Viewport section for the focused card.\"\n    \n    def viewport_section_after(self) -&gt; str:  # Cards after focused (1fr, justify-start)\n            \"\"\"Viewport section for context cards after focused card.\"\"\"\n            return f\"{self.prefix}-viewport-section-after\"\n    \n        # --- Dynamic slot IDs ---\n    \n        def viewport_slot(\n            self,\n            item_index: int  # Item index (negative or &gt;= total for placeholders)\n        ) -&gt; str:  # Slot element ID tied to virtual item position\n        \"Viewport section for context cards after focused card.\"\n    \n    def viewport_slot(\n            self,\n            item_index: int  # Item index (negative or &gt;= total for placeholders)\n        ) -&gt; str:  # Slot element ID tied to virtual item position\n        \"ID for a viewport slot. Works for real items and placeholders.\"\n    \n    def card_count_select(self) -&gt; str:  # Card count dropdown\n            \"\"\"Card count selector dropdown.\"\"\"\n            return f\"{self.prefix}-card-count-select\"\n    \n        @property\n        def width_slider(self) -&gt; str:  # Width range slider\n        \"Card count selector dropdown.\"\n    \n    def width_slider(self) -&gt; str:  # Width range slider\n            \"\"\"Card stack width slider.\"\"\"\n            return f\"{self.prefix}-width-slider\"\n    \n        @property\n        def scale_slider(self) -&gt; str:  # Scale range slider\n        \"Card stack width slider.\"\n    \n    def scale_slider(self) -&gt; str:  # Scale range slider\n            \"\"\"Card stack scale slider.\"\"\"\n            return f\"{self.prefix}-scale-slider\"\n    \n        # --- Status elements ---\n    \n        @property\n        def progress(self) -&gt; str:  # Progress indicator\n        \"Card stack scale slider.\"\n    \n    def progress(self) -&gt; str:  # Progress indicator\n            \"\"\"Progress indicator element.\"\"\"\n            return f\"{self.prefix}-progress\"\n    \n        @property\n        def loading(self) -&gt; str:  # Loading state container\n        \"Progress indicator element.\"\n    \n    def loading(self) -&gt; str:  # Loading state container\n            \"\"\"Loading state container.\"\"\"\n            return f\"{self.prefix}-loading\"\n    \n        # --- Hidden inputs ---\n    \n        @property\n        def focused_index_input(self) -&gt; str:  # Hidden input for keyboard nav focus recovery\n        \"Loading state container.\"\n    \n    def focused_index_input(self) -&gt; str:  # Hidden input for keyboard nav focus recovery\n        \"Hidden input storing the focused index for HTMX submissions.\"\n\n\n\nModels (models.ipynb)\n\nCore dataclasses for card stack state, render context, and URL routing.\n\n\nImport\nfrom cjm_fasthtml_card_stack.core.models import (\n    CardStackState,\n    CardRenderContext,\n    CardStackUrls\n)\n\n\nClasses\n@dataclass\nclass CardStackState:\n    \"Viewport state for a card stack instance.\"\n    \n    focused_index: int = 0  # Index of focused item in the items list\n    visible_count: int = 3  # Number of card slots visible in viewport\n    card_width: int = 80  # Max width of card stack inner container in rem\n    card_scale: int = 100  # Content scale percentage (50-200)\n    active_mode: Optional[str]  # Current interaction mode name (consumer-defined)\n    focus_position: Optional[int]  # Slot offset for focused card (None=center, -1=bottom)\n@dataclass\nclass CardRenderContext:\n    \"Context passed to the consumer's render_card callback.\"\n    \n    card_role: str  # \"focused\" or \"context\"\n    index: int  # Item's position in the full items list\n    total_items: int  # Total item count\n    is_first: bool  # Whether this is the first item\n    is_last: bool  # Whether this is the last item\n    active_mode: Optional[str]  # Current interaction mode\n    card_scale: int  # Scale percentage (50-200)\n    distance_from_focus: int  # Signed slot offset from focused card (0=focused)\n@dataclass\nclass CardStackUrls:\n    \"URL bundle for card stack navigation and viewport operations.\"\n    \n    nav_up: str = ''  # Navigate to previous item\n    nav_down: str = ''  # Navigate to next item\n    nav_first: str = ''  # Navigate to first item\n    nav_last: str = ''  # Navigate to last item\n    nav_page_up: str = ''  # Page jump up\n    nav_page_down: str = ''  # Page jump down\n    nav_to_index: str = ''  # Navigate to specific index (click-to-focus)\n    update_viewport: str = ''  # Change visible_count (full viewport re-render)\n    save_width: str = ''  # Persist card_width\n    save_scale: str = ''  # Persist card_scale\n\n\n\nJS: Page Navigation (navigation.ipynb)\n\nJavaScript generator for page jump and first/last navigation helpers.\n\n\nImport\nfrom cjm_fasthtml_card_stack.js.navigation import (\n    generate_page_nav_js\n)\n\n\nFunctions\ndef generate_page_nav_js(\n    button_ids: CardStackButtonIds,  # Button IDs for navigation triggers\n) -&gt; str:  # JavaScript code fragment for page navigation\n    \"Generate JS for page-based and first/last navigation functions.\"\n\n\n\nProgress (progress.ipynb)\n\nProgress indicator showing the current position within the card stack.\n\n\nImport\nfrom cjm_fasthtml_card_stack.components.progress import (\n    render_progress_indicator\n)\n\n\nFunctions\ndef render_progress_indicator(\n    focused_index: int,  # Currently focused item index (0-based)\n    total_items: int,  # Total number of items\n    ids: CardStackHtmlIds,  # HTML IDs for this card stack instance\n    label: str = \"Item\",  # Label prefix (e.g., \"Item\", \"Segment\", \"Card\")\n    oob: bool = False,  # Whether to render as OOB swap\n) -&gt; Any:  # Progress indicator component\n    \"Render position indicator showing current item in the collection.\"\n\n\n\nRouter (router.ipynb)\n\nConvenience router factory that wires up standard card stack routes (Tier 2 API).\n\n\nImport\nfrom cjm_fasthtml_card_stack.routes.router import (\n    init_card_stack_router\n)\n\n\nFunctions\ndef init_card_stack_router(\n    config: CardStackConfig,  # Card stack configuration\n    state_getter: Callable[[], CardStackState],  # Function to get current state\n    state_setter: Callable[[CardStackState], None],  # Function to save state\n    get_items: Callable[[], List[Any]],  # Function to get current items list\n    render_card: Callable,  # Card renderer callback: (item, CardRenderContext) -&gt; FT\n    route_prefix: str = \"/card-stack\",  # Route prefix for all card stack routes\n    progress_label: str = \"Item\",  # Label for progress indicator\n) -&gt; Tuple[APIRouter, CardStackUrls]:  # (router, urls) tuple\n    \"Initialize an APIRouter with all standard card stack routes.\"\n\n\n\nJS: Scroll Navigation (scroll.ipynb)\n\nJavaScript generator for scroll-to-nav conversion.\n\n\nImport\nfrom cjm_fasthtml_card_stack.js.scroll import (\n    generate_scroll_nav_js\n)\n\n\nFunctions\ndef generate_scroll_nav_js(\n    ids: CardStackHtmlIds,  # HTML IDs for this card stack instance\n    button_ids: CardStackButtonIds,  # Button IDs for navigation triggers\n    disable_in_modes: Tuple[str, ...] = (),  # Mode names where scroll nav is suppressed\n) -&gt; str:  # JavaScript code fragment for scroll navigation\n    \"Generate JS for scroll wheel to navigation conversion.\"\n\n\n\nStates (states.ipynb)\n\nLoading, empty, and placeholder card components for the card stack viewport.\n\n\nImport\nfrom cjm_fasthtml_card_stack.components.states import (\n    render_placeholder_card,\n    render_loading_state,\n    render_empty_state\n)\n\n\nFunctions\ndef render_placeholder_card(\n    placeholder_type: Literal[\"start\", \"end\"],  # Which edge of the list\n) -&gt; Any:  # Placeholder card component\n    \"Render a placeholder card for viewport edges.\"\ndef render_loading_state(\n    ids: CardStackHtmlIds,  # HTML IDs for this card stack instance\n    message: str = \"Loading...\",  # Loading message text\n) -&gt; Any:  # Loading component\n    \"Render loading state with spinner and message.\"\ndef render_empty_state(\n    ids: CardStackHtmlIds,  # HTML IDs for this card stack instance\n    title: str = \"No items available\",  # Main empty state message\n    subtitle: str = \"\",  # Optional subtitle text\n) -&gt; Any:  # Empty state component\n    \"Render empty state when no items exist.\"\n\n\n\nJS: Touch Navigation (touch.ipynb)\n\nJavaScript generator for touch-to-nav conversion: swipe, drag,\n\n\nImport\nfrom cjm_fasthtml_card_stack.js.touch import (\n    generate_touch_nav_js\n)\n\n\nFunctions\ndef generate_touch_nav_js(\n    ids: CardStackHtmlIds,  # HTML IDs for this card stack instance\n    button_ids: CardStackButtonIds,  # Button IDs for navigation triggers\n    disable_in_modes: Tuple[str, ...] = (),  # Mode names where touch nav is suppressed\n) -&gt; str:  # JavaScript code fragment for touch navigation\n    \"Generate JS for touch gesture to navigation conversion.\"\n\n\n\nViewport (viewport.ipynb)\n\nCard stack viewport with 3-section CSS Grid layout, slot rendering,\n\n\nImport\nfrom cjm_fasthtml_card_stack.components.viewport import (\n    render_slot_card,\n    render_all_slots_oob,\n    render_viewport\n)\n\n\nFunctions\ndef _render_mode_sync_script(\n    active_mode: Optional[str] = None,  # Active keyboard mode name (None = navigation)\n) -&gt; Any:  # Script element that syncs keyboard mode state\n    \"Generate script to sync keyboard navigation mode with rendered UI state.\"\ndef _render_click_overlay(\n    item_index: int,  # Index of the item this slot represents\n    urls: CardStackUrls,  # URL bundle for navigation\n) -&gt; Any:  # Transparent click overlay element\n    \"Render transparent click-to-focus overlay for a context card slot.\"\ndef render_slot_card(\n    slot_index: int,  # Index of this slot in the viewport (0-based)\n    focus_slot: int,  # Which slot is the focused position\n    card_items: List[Any],  # Full items list\n    item_index: int,  # Item index (negative or &gt;= len for placeholder)\n    render_card: Callable,  # Callback: (item, CardRenderContext) -&gt; FT\n    state: CardStackState,  # Current card stack state\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    urls: CardStackUrls,  # URL bundle for navigation\n    oob: bool = False,  # Whether to render as OOB swap\n) -&gt; Any:  # Slot content wrapper\n    \"Render a single card for a viewport slot.\"\ndef render_all_slots_oob(\n    card_items: List[Any],  # All data items\n    state: CardStackState,  # Current card stack state\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    urls: CardStackUrls,  # URL bundle for navigation\n    render_card: Callable,  # Card renderer callback\n) -&gt; List[Any]:  # List of OOB elements (3 sections)\n    \"Render all viewport sections with OOB swap for granular updates.\"\ndef _grid_template_rows(\n    focus_position: Optional[int] = None,  # Focus slot offset (None=center, -1=bottom, 0=top)\n) -&gt; str:  # CSS grid-template-rows value\n    \"Compute CSS grid-template-rows based on focus position intent.\"\ndef render_viewport(\n    card_items: List[Any],  # All data items\n    state: CardStackState,  # Current card stack state\n    config: CardStackConfig,  # Card stack configuration\n    ids: CardStackHtmlIds,  # HTML IDs for this instance\n    urls: CardStackUrls,  # URL bundle for navigation\n    render_card: Callable,  # Card renderer callback\n    form_input_name: str = \"focused_index\",  # Name for the focused index hidden input\n) -&gt; Any:  # Viewport component with 3-section layout\n    \"Render the card stack viewport with 3-section CSS Grid layout.\"\n\n\n\nJS: Viewport Height (viewport.ipynb)\n\nJavaScript generator for dynamic viewport height calculation.\n\n\nImport\nfrom cjm_fasthtml_card_stack.js.viewport import (\n    generate_viewport_height_js\n)\n\n\nFunctions\ndef generate_viewport_height_js(\n    \"\"\"\n    Generate JS for dynamic viewport height calculation.\n    \n    Uses position-based measurement to determine available space. Temporarily\n    collapses the card stack to measure its natural top position, then\n    calculates available height based on actual visual positions.\n    \n    This approach handles margin collapsing, flex gap, grid gap, and any\n    other CSS layout mechanism automatically.\n    \n    Debug mode: Set `window.cardStackDebug = true` in browser console\n    to log all intermediate calculation values.\n    \"\"\"",
    "crumbs": [
      "cjm-fasthtml-card-stack"
    ]
  },
  {
    "objectID": "components/viewport.html",
    "href": "components/viewport.html",
    "title": "Viewport",
    "section": "",
    "text": "Synchronizes the keyboard navigation mode with the rendered UI state after HTMX swaps.",
    "crumbs": [
      "components",
      "Viewport"
    ]
  },
  {
    "objectID": "components/viewport.html#mode-sync-script",
    "href": "components/viewport.html#mode-sync-script",
    "title": "Viewport",
    "section": "",
    "text": "Synchronizes the keyboard navigation mode with the rendered UI state after HTMX swaps.",
    "crumbs": [
      "components",
      "Viewport"
    ]
  },
  {
    "objectID": "components/viewport.html#click-to-focus-overlay",
    "href": "components/viewport.html#click-to-focus-overlay",
    "title": "Viewport",
    "section": "Click-to-Focus Overlay",
    "text": "Click-to-Focus Overlay\nTransparent overlay added to context card slots when click_to_focus is enabled. Intercepts all clicks, enforcing the navigate-first-then-interact pattern.",
    "crumbs": [
      "components",
      "Viewport"
    ]
  },
  {
    "objectID": "components/viewport.html#render_slot_card",
    "href": "components/viewport.html#render_slot_card",
    "title": "Viewport",
    "section": "render_slot_card",
    "text": "render_slot_card\nRenders a single card for a viewport slot. Handles focused/context styling, placeholder rendering, click-to-focus overlays, and CardRenderContext construction.\n\nsource\n\nrender_slot_card\n\ndef render_slot_card(\n    slot_index:int, # Index of this slot in the viewport (0-based)\n    focus_slot:int, # Which slot is the focused position\n    card_items:List, # Full items list\n    item_index:int, # Item index (negative or &gt;= len for placeholder)\n    render_card:Callable, # Callback: (item, CardRenderContext) -&gt; FT\n    state:CardStackState, # Current card stack state\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    oob:bool=False, # Whether to render as OOB swap\n)-&gt;Any: # Slot content wrapper\n\nRender a single card for a viewport slot.\n\n# Test render_slot_card\nfrom fasthtml.common import to_xml, P as FP\nfrom cjm_fasthtml_card_stack.core.config import _reset_prefix_counter\n\n_reset_prefix_counter()\nconfig = CardStackConfig(prefix=\"test\")\nids = CardStackHtmlIds(prefix=\"test\")\nstate = CardStackState()\nurls = CardStackUrls(nav_to_index=\"/card-stack/nav_to_index\")\nitems_list = [\"Item A\", \"Item B\", \"Item C\", \"Item D\", \"Item E\"]\n\ndef simple_render(item, ctx):\n    return FP(f\"{item} [{ctx.card_role}]\")\n\n# Test focused card (slot 1, center of 3, item_index=2)\ncard_el = render_slot_card(\n    slot_index=1, focus_slot=1, card_items=items_list, item_index=2,\n    render_card=simple_render, state=state, config=config, ids=ids, urls=urls\n)\nhtml = to_xml(card_el)\nassert 'id=\"test-item-slot-2\"' in html  # Item-based ID\nassert 'tabindex=\"0\"' in html  # Focused is tabbable\nassert \"Item C [focused]\" in html\nassert \"shadow-lg\" in html  # Focus shadow\nprint(\"Focused card test passed!\")\n\nFocused card test passed!\n\n\n\n# Test context card (slot 0, item_index=1)\ncard_el = render_slot_card(\n    slot_index=0, focus_slot=1, card_items=items_list, item_index=1,\n    render_card=simple_render, state=state, config=config, ids=ids, urls=urls\n)\nhtml = to_xml(card_el)\nassert 'id=\"test-item-slot-1\"' in html  # Item-based ID\nassert 'tabindex=\"-1\"' in html  # Context not tabbable\nassert \"Item B [context]\" in html\nassert \"shadow-lg\" not in html  # No focus shadow\nassert 'p-[var(--test-slot-padding)]' in html  # Configurable slot padding\nprint(\"Context card test passed!\")\n\nContext card test passed!\n\n\n\n# Test placeholder card (negative item_index, slot 0 before focus)\ncard_el = render_slot_card(\n    slot_index=0, focus_slot=1, card_items=items_list, item_index=-1,\n    render_card=simple_render, state=state, config=config, ids=ids, urls=urls\n)\nhtml = to_xml(card_el)\nassert 'id=\"test-item-slot--1\"' in html  # Negative index for before-start placeholder\nassert \"Beginning\" in html  # Before focus -&gt; \"start\" placeholder\nprint(\"Placeholder card (before) test passed!\")\n\n# Test placeholder card (item_index &gt;= total_items, after focus)\ncard_el = render_slot_card(\n    slot_index=2, focus_slot=1, card_items=items_list, item_index=5,\n    render_card=simple_render, state=state, config=config, ids=ids, urls=urls\n)\nhtml = to_xml(card_el)\nassert 'id=\"test-item-slot-5\"' in html  # Index &gt;= total for after-end placeholder\nassert \"End\" in html  # After focus -&gt; \"end\" placeholder\nprint(\"Placeholder card (after) test passed!\")\n\nPlaceholder card (before) test passed!\nPlaceholder card (after) test passed!\n\n\n\n# Test click-to-focus overlay\nclick_config = CardStackConfig(prefix=\"click\", click_to_focus=True)\nclick_ids = CardStackHtmlIds(prefix=\"click\")\ncard_el = render_slot_card(\n    slot_index=0, focus_slot=1, card_items=items_list, item_index=1,\n    render_card=simple_render, state=state, config=click_config, ids=click_ids, urls=urls\n)\nhtml = to_xml(card_el)\nassert 'hx-post=\"/card-stack/nav_to_index\"' in html  # Overlay present\nassert 'relative' in html  # Container has relative positioning\nassert 'inset-0' in html  # Overlay covers full area\n\n# Focused card should NOT have overlay even with click_to_focus=True\ncard_el = render_slot_card(\n    slot_index=1, focus_slot=1, card_items=items_list, item_index=2,\n    render_card=simple_render, state=state, config=click_config, ids=click_ids, urls=urls\n)\nhtml = to_xml(card_el)\nassert 'hx-post' not in html  # No overlay on focused card\n\n# Placeholder should NOT have overlay even with click_to_focus=True\ncard_el = render_slot_card(\n    slot_index=0, focus_slot=1, card_items=items_list, item_index=-1,\n    render_card=simple_render, state=state, config=click_config, ids=click_ids, urls=urls\n)\nhtml = to_xml(card_el)\nassert 'hx-post' not in html  # No overlay on placeholder\nprint(\"Click-to-focus overlay tests passed!\")\n\nClick-to-focus overlay tests passed!\n\n\n\n# Test CardRenderContext is correctly populated\ncaptured_contexts = []\n\ndef capturing_render(item, ctx):\n    captured_contexts.append(ctx)\n    return FP(item)\n\ncaptured_contexts.clear()\nrender_slot_card(\n    slot_index=1, focus_slot=1, card_items=items_list, item_index=0,\n    render_card=capturing_render, state=CardStackState(active_mode=\"edit\", card_scale=75),\n    config=config, ids=ids, urls=urls\n)\nctx = captured_contexts[0]\nassert ctx.card_role == \"focused\"\nassert ctx.index == 0\nassert ctx.total_items == 5\nassert ctx.is_first == True\nassert ctx.is_last == False\nassert ctx.active_mode == \"edit\"\nassert ctx.card_scale == 75\nassert ctx.distance_from_focus == 0\nprint(\"CardRenderContext population test passed!\")\n\nCardRenderContext population test passed!",
    "crumbs": [
      "components",
      "Viewport"
    ]
  },
  {
    "objectID": "components/viewport.html#render_all_slots_oob",
    "href": "components/viewport.html#render_all_slots_oob",
    "title": "Viewport",
    "section": "render_all_slots_oob",
    "text": "render_all_slots_oob\nRenders all viewport sections with OOB swap for granular updates. Returns OOB elements for the 3-section layout.\n\nsource\n\nrender_all_slots_oob\n\ndef render_all_slots_oob(\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n)-&gt;List: # List of OOB elements (3 sections)\n\nRender all viewport sections with OOB swap for granular updates.\n\n# Test render_all_slots_oob\nstate = CardStackState(focused_index=2, visible_count=3)\nsections = render_all_slots_oob(\n    card_items=items_list, state=state, config=config,\n    ids=ids, urls=urls, render_card=simple_render\n)\nassert len(sections) == 3\n\nhtml_before = to_xml(sections[0])\nassert 'id=\"test-viewport-section-before\"' in html_before\nassert 'hx-swap-oob=\"innerHTML\"' in html_before\n\nhtml_focused = to_xml(sections[1])\nassert 'id=\"test-viewport-section-focused\"' in html_focused\n\nhtml_after = to_xml(sections[2])\nassert 'id=\"test-viewport-section-after\"' in html_after\nprint(\"render_all_slots_oob tests passed!\")\n\nrender_all_slots_oob tests passed!",
    "crumbs": [
      "components",
      "Viewport"
    ]
  },
  {
    "objectID": "components/viewport.html#grid-template-helpers",
    "href": "components/viewport.html#grid-template-helpers",
    "title": "Viewport",
    "section": "Grid Template Helpers",
    "text": "Grid Template Helpers\nThe CSS Grid template is determined by the focus position intent and stays stable across visible_count changes: - Center (None): 1fr auto 1fr - Bottom (-1): 1fr auto - Top (0): auto 1fr\n\n# Test grid template computation — stable across visible_count changes\nassert _grid_template_rows(None) == \"1fr auto 1fr\"   # Center: always 3-section\nassert _grid_template_rows(-1) == \"1fr auto\"          # Bottom: focused last\nassert _grid_template_rows(0) == \"auto 1fr\"           # Top: focused first\nassert _grid_template_rows(2) == \"1fr auto 1fr\"       # Custom positive: 3-section\nprint(\"Grid template tests passed!\")\n\nGrid template tests passed!",
    "crumbs": [
      "components",
      "Viewport"
    ]
  },
  {
    "objectID": "components/viewport.html#render_viewport",
    "href": "components/viewport.html#render_viewport",
    "title": "Viewport",
    "section": "render_viewport",
    "text": "render_viewport\nMain viewport renderer. Builds the 3-section CSS Grid layout with opacity reveal pattern.\n\nsource\n\nrender_viewport\n\ndef render_viewport(\n    card_items:List, # All data items\n    state:CardStackState, # Current card stack state\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    urls:CardStackUrls, # URL bundle for navigation\n    render_card:Callable, # Card renderer callback\n    form_input_name:str='focused_index', # Name for the focused index hidden input\n)-&gt;Any: # Viewport component with 3-section layout\n\nRender the card stack viewport with 3-section CSS Grid layout.\n\n# Test render_viewport\nstate = CardStackState(focused_index=2, visible_count=5, card_width=60)\nviewport = render_viewport(\n    card_items=items_list, state=state, config=config,\n    ids=ids, urls=urls, render_card=simple_render\n)\nhtml = to_xml(viewport)\nassert 'id=\"test-card-stack\"' in html\nassert 'id=\"test-card-stack-inner\"' in html\nassert 'id=\"test-viewport-section-before\"' in html\nassert 'id=\"test-viewport-section-focused\"' in html\nassert 'id=\"test-viewport-section-after\"' in html\nassert 'opacity-0' in html  # Opacity reveal via Tailwind class\nassert 'transition-opacity' in html\nassert 'duration-150' in html\nassert 'ease-in' in html\nassert 'data-focused-index=\"2\"' in html\nassert 'data-total-items=\"5\"' in html\nassert 'data-visible-count=\"5\"' in html\nassert '1fr auto 1fr' in html  # Center focus grid\nassert 'max-width: 60rem' in html\nassert 'touch-none' in html  # Touch gesture capture\n\n# Verify focused_index hidden input is included\nassert 'id=\"test-focused-index\"' in html\nassert 'name=\"focused_index\"' in html\nassert 'value=\"2\"' in html\n\n# CSS custom properties on outer container\nassert '--test-section-gap: 1rem' in html\nassert '--test-slot-padding: 0.25rem' in html\nassert '--test-viewport-padding-x: 0.5rem' in html\nassert '--test-viewport-padding-y: 0.5rem' in html\nassert '--test-focus-padding-x: 0.5rem' in html\nassert '--test-focus-padding-b: 1rem' in html\n\n# Arbitrary value Tailwind classes referencing CSS custom properties\nassert 'gap-[var(--test-section-gap)]' in html\nassert 'px-[var(--test-viewport-padding-x)]' in html\nassert 'py-[var(--test-viewport-padding-y)]' in html\nassert 'px-[var(--test-focus-padding-x)]' in html\nassert 'pb-[var(--test-focus-padding-b)]' in html\nprint(\"render_viewport tests passed!\")\n\nrender_viewport tests passed!\n\n\n\n# Test bottom-anchored viewport\nstate = CardStackState(focused_index=2, visible_count=3, focus_position=-1)\nviewport = render_viewport(\n    card_items=items_list, state=state, config=config,\n    ids=ids, urls=urls, render_card=simple_render\n)\nhtml = to_xml(viewport)\nassert 'grid-template-rows: 1fr auto;' in html  # Bottom focus grid\nassert 'Item C [focused]' in html  # Item at index 2 is focused\nprint(\"Bottom-anchored viewport test passed!\")\n\nBottom-anchored viewport test passed!\n\n\n\n# Test viewport content correctness with center focus\nstate = CardStackState(focused_index=2, visible_count=3)\nviewport = render_viewport(\n    card_items=items_list, state=state, config=config,\n    ids=ids, urls=urls, render_card=simple_render\n)\nhtml = to_xml(viewport)\nassert \"Item B [context]\" in html   # Before focused\nassert \"Item C [focused]\" in html   # Focused\nassert \"Item D [context]\" in html   # After focused\nassert \"Item A\" not in html          # Not visible\nassert \"Item E\" not in html          # Not visible\nprint(\"Viewport content correctness test passed!\")\n\nViewport content correctness test passed!",
    "crumbs": [
      "components",
      "Viewport"
    ]
  },
  {
    "objectID": "components/states.html",
    "href": "components/states.html",
    "title": "States",
    "section": "",
    "text": "Rendered in viewport slots that fall outside the items list (e.g., before the first item or after the last).\n\nsource\n\n\n\ndef render_placeholder_card(\n    placeholder_type:Literal, # Which edge of the list\n)-&gt;Any: # Placeholder card component\n\nRender a placeholder card for viewport edges.\n\n# Test render_placeholder_card\nfrom fasthtml.common import to_xml\n\nstart_card = render_placeholder_card(\"start\")\nhtml = to_xml(start_card)\nassert \"Beginning\" in html\nassert 'data-placeholder-type=\"start\"' in html\n\nend_card = render_placeholder_card(\"end\")\nhtml = to_xml(end_card)\nassert \"End\" in html\nassert 'data-placeholder-type=\"end\"' in html\nprint(\"render_placeholder_card tests passed!\")\n\nrender_placeholder_card tests passed!",
    "crumbs": [
      "components",
      "States"
    ]
  },
  {
    "objectID": "components/states.html#render_placeholder_card",
    "href": "components/states.html#render_placeholder_card",
    "title": "States",
    "section": "",
    "text": "Rendered in viewport slots that fall outside the items list (e.g., before the first item or after the last).\n\nsource\n\n\n\ndef render_placeholder_card(\n    placeholder_type:Literal, # Which edge of the list\n)-&gt;Any: # Placeholder card component\n\nRender a placeholder card for viewport edges.\n\n# Test render_placeholder_card\nfrom fasthtml.common import to_xml\n\nstart_card = render_placeholder_card(\"start\")\nhtml = to_xml(start_card)\nassert \"Beginning\" in html\nassert 'data-placeholder-type=\"start\"' in html\n\nend_card = render_placeholder_card(\"end\")\nhtml = to_xml(end_card)\nassert \"End\" in html\nassert 'data-placeholder-type=\"end\"' in html\nprint(\"render_placeholder_card tests passed!\")\n\nrender_placeholder_card tests passed!",
    "crumbs": [
      "components",
      "States"
    ]
  },
  {
    "objectID": "components/states.html#render_loading_state",
    "href": "components/states.html#render_loading_state",
    "title": "States",
    "section": "render_loading_state",
    "text": "render_loading_state\nDisplayed while the card stack is initializing (e.g., fetching items from a service).\n\nsource\n\nrender_loading_state\n\ndef render_loading_state(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    message:str='Loading...', # Loading message text\n)-&gt;Any: # Loading component\n\nRender loading state with spinner and message.\n\n# Test render_loading_state\nids = CardStackHtmlIds(prefix=\"cs0\")\nloading_el = render_loading_state(ids)\nhtml = to_xml(loading_el)\nassert 'id=\"cs0-loading\"' in html\nassert \"Loading...\" in html\n\n# Test custom message\nloading_el = render_loading_state(ids, message=\"Initializing segments...\")\nhtml = to_xml(loading_el)\nassert \"Initializing segments...\" in html\nprint(\"render_loading_state tests passed!\")\n\nrender_loading_state tests passed!",
    "crumbs": [
      "components",
      "States"
    ]
  },
  {
    "objectID": "components/states.html#render_empty_state",
    "href": "components/states.html#render_empty_state",
    "title": "States",
    "section": "render_empty_state",
    "text": "render_empty_state\nDisplayed when the items list is empty.\n\nsource\n\nrender_empty_state\n\ndef render_empty_state(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    title:str='No items available', # Main empty state message\n    subtitle:str='', # Optional subtitle text\n)-&gt;Any: # Empty state component\n\nRender empty state when no items exist.\n\n# Test render_empty_state\nids = CardStackHtmlIds(prefix=\"cs0\")\nempty_el = render_empty_state(ids)\nhtml = to_xml(empty_el)\nassert 'id=\"cs0-card-stack-empty\"' in html\nassert \"No items available\" in html\n\n# Test with subtitle\nempty_el = render_empty_state(ids, title=\"Nothing here\", subtitle=\"Add items to begin\")\nhtml = to_xml(empty_el)\nassert \"Nothing here\" in html\nassert \"Add items to begin\" in html\nprint(\"render_empty_state tests passed!\")\n\nrender_empty_state tests passed!",
    "crumbs": [
      "components",
      "States"
    ]
  },
  {
    "objectID": "components/progress.html",
    "href": "components/progress.html",
    "title": "Progress",
    "section": "",
    "text": "Displays the current focused position as “Item X of Y” with 1-based indexing for user-facing display.\n\nsource\n\n\n\ndef render_progress_indicator(\n    focused_index:int, # Currently focused item index (0-based)\n    total_items:int, # Total number of items\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    label:str='Item', # Label prefix (e.g., \"Item\", \"Segment\", \"Card\")\n    oob:bool=False, # Whether to render as OOB swap\n)-&gt;Any: # Progress indicator component\n\nRender position indicator showing current item in the collection.\n\n# Test render_progress_indicator\nfrom fasthtml.common import to_xml\n\nids = CardStackHtmlIds(prefix=\"cs0\")\nprogress = render_progress_indicator(0, 20, ids)\nhtml = to_xml(progress)\nassert 'id=\"cs0-progress\"' in html\nassert \"Item 1 of 20\" in html\nprint(\"Basic progress test passed!\")\n\nBasic progress test passed!\n\n\n\n# Test custom label\nprogress = render_progress_indicator(4, 100, ids, label=\"Segment\")\nhtml = to_xml(progress)\nassert \"Segment 5 of 100\" in html\nprint(\"Custom label test passed!\")\n\nCustom label test passed!\n\n\n\n# Test OOB mode\nprogress = render_progress_indicator(9, 50, ids, oob=True)\nhtml = to_xml(progress)\nassert 'hx-swap-oob=\"true\"' in html\n\n# Non-OOB should not have the attribute\nprogress = render_progress_indicator(9, 50, ids, oob=False)\nhtml = to_xml(progress)\nassert 'hx-swap-oob' not in html\nprint(\"OOB mode tests passed!\")\n\nOOB mode tests passed!\n\n\n\n# Test number formatting with large values\nprogress = render_progress_indicator(999, 1500, ids)\nhtml = to_xml(progress)\nassert \"Item 1,000 of 1,500\" in html\nprint(\"Number formatting test passed!\")\n\nNumber formatting test passed!",
    "crumbs": [
      "components",
      "Progress"
    ]
  },
  {
    "objectID": "components/progress.html#render_progress_indicator",
    "href": "components/progress.html#render_progress_indicator",
    "title": "Progress",
    "section": "",
    "text": "Displays the current focused position as “Item X of Y” with 1-based indexing for user-facing display.\n\nsource\n\n\n\ndef render_progress_indicator(\n    focused_index:int, # Currently focused item index (0-based)\n    total_items:int, # Total number of items\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    label:str='Item', # Label prefix (e.g., \"Item\", \"Segment\", \"Card\")\n    oob:bool=False, # Whether to render as OOB swap\n)-&gt;Any: # Progress indicator component\n\nRender position indicator showing current item in the collection.\n\n# Test render_progress_indicator\nfrom fasthtml.common import to_xml\n\nids = CardStackHtmlIds(prefix=\"cs0\")\nprogress = render_progress_indicator(0, 20, ids)\nhtml = to_xml(progress)\nassert 'id=\"cs0-progress\"' in html\nassert \"Item 1 of 20\" in html\nprint(\"Basic progress test passed!\")\n\nBasic progress test passed!\n\n\n\n# Test custom label\nprogress = render_progress_indicator(4, 100, ids, label=\"Segment\")\nhtml = to_xml(progress)\nassert \"Segment 5 of 100\" in html\nprint(\"Custom label test passed!\")\n\nCustom label test passed!\n\n\n\n# Test OOB mode\nprogress = render_progress_indicator(9, 50, ids, oob=True)\nhtml = to_xml(progress)\nassert 'hx-swap-oob=\"true\"' in html\n\n# Non-OOB should not have the attribute\nprogress = render_progress_indicator(9, 50, ids, oob=False)\nhtml = to_xml(progress)\nassert 'hx-swap-oob' not in html\nprint(\"OOB mode tests passed!\")\n\nOOB mode tests passed!\n\n\n\n# Test number formatting with large values\nprogress = render_progress_indicator(999, 1500, ids)\nhtml = to_xml(progress)\nassert \"Item 1,000 of 1,500\" in html\nprint(\"Number formatting test passed!\")\n\nNumber formatting test passed!",
    "crumbs": [
      "components",
      "Progress"
    ]
  },
  {
    "objectID": "components/controls.html",
    "href": "components/controls.html",
    "title": "Controls",
    "section": "",
    "text": "Range slider for adjusting the card stack viewport width. The oninput handler references the namespaced JS function window.cardStacks[prefix].updateWidth().\n\nsource\n\n\n\ndef render_width_slider(\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    card_width:int=80, # Current card width in rem\n)-&gt;Any: # Width slider component\n\nRender the card stack width slider control.\n\n# Test render_width_slider\nfrom fasthtml.common import to_xml\nfrom cjm_fasthtml_card_stack.core.config import CardStackConfig, _reset_prefix_counter\n\n_reset_prefix_counter()\nconfig = CardStackConfig(prefix=\"test\")\nids = CardStackHtmlIds(prefix=\"test\")\n\nslider = render_width_slider(config, ids, card_width=60)\nhtml = to_xml(slider)\nassert 'id=\"test-width-slider\"' in html\nassert 'min=\"30\"' in html\nassert 'max=\"120\"' in html\nassert 'step=\"5\"' in html\nassert 'value=\"60\"' in html\nassert \"window.cardStacks['test'].updateWidth\" in html\nassert \"Narrow\" in html\nassert \"Wide\" in html\nprint(\"render_width_slider tests passed!\")\n\nrender_width_slider tests passed!",
    "crumbs": [
      "components",
      "Controls"
    ]
  },
  {
    "objectID": "components/controls.html#render_width_slider",
    "href": "components/controls.html#render_width_slider",
    "title": "Controls",
    "section": "",
    "text": "Range slider for adjusting the card stack viewport width. The oninput handler references the namespaced JS function window.cardStacks[prefix].updateWidth().\n\nsource\n\n\n\ndef render_width_slider(\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    card_width:int=80, # Current card width in rem\n)-&gt;Any: # Width slider component\n\nRender the card stack width slider control.\n\n# Test render_width_slider\nfrom fasthtml.common import to_xml\nfrom cjm_fasthtml_card_stack.core.config import CardStackConfig, _reset_prefix_counter\n\n_reset_prefix_counter()\nconfig = CardStackConfig(prefix=\"test\")\nids = CardStackHtmlIds(prefix=\"test\")\n\nslider = render_width_slider(config, ids, card_width=60)\nhtml = to_xml(slider)\nassert 'id=\"test-width-slider\"' in html\nassert 'min=\"30\"' in html\nassert 'max=\"120\"' in html\nassert 'step=\"5\"' in html\nassert 'value=\"60\"' in html\nassert \"window.cardStacks['test'].updateWidth\" in html\nassert \"Narrow\" in html\nassert \"Wide\" in html\nprint(\"render_width_slider tests passed!\")\n\nrender_width_slider tests passed!",
    "crumbs": [
      "components",
      "Controls"
    ]
  },
  {
    "objectID": "components/controls.html#render_scale_slider",
    "href": "components/controls.html#render_scale_slider",
    "title": "Controls",
    "section": "render_scale_slider",
    "text": "render_scale_slider\nRange slider for adjusting card content scale. Works the same way as the width slider but controls the card_scale percentage.\n\nsource\n\nrender_scale_slider\n\ndef render_scale_slider(\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    card_scale:int=100, # Current scale percentage\n)-&gt;Any: # Scale slider component\n\nRender the card stack scale slider control.\n\n# Test render_scale_slider\nslider = render_scale_slider(config, ids, card_scale=150)\nhtml = to_xml(slider)\nassert 'id=\"test-scale-slider\"' in html\nassert 'min=\"50\"' in html\nassert 'max=\"200\"' in html\nassert 'step=\"10\"' in html\nassert 'value=\"150\"' in html\nassert \"window.cardStacks['test'].updateScale\" in html\nassert \"Smaller\" in html\nassert \"Larger\" in html\nprint(\"render_scale_slider tests passed!\")\n\nrender_scale_slider tests passed!",
    "crumbs": [
      "components",
      "Controls"
    ]
  },
  {
    "objectID": "components/controls.html#render_card_count_select",
    "href": "components/controls.html#render_card_count_select",
    "title": "Controls",
    "section": "render_card_count_select",
    "text": "render_card_count_select\nDropdown selector for changing the number of visible cards in the viewport. Triggers a full viewport re-render via the namespaced JS function.\n\nsource\n\nrender_card_count_select\n\ndef render_card_count_select(\n    config:CardStackConfig, # Card stack configuration\n    ids:CardStackHtmlIds, # HTML IDs for this instance\n    current_count:int=3, # Currently selected card count\n    is_auto_mode:bool=False, # Whether auto-adjust mode is active\n)-&gt;Any: # Card count dropdown component\n\nRender the card count dropdown selector.\n\n# Test render_card_count_select\nselect_el = render_card_count_select(config, ids, current_count=5)\nhtml = to_xml(select_el)\nassert 'id=\"test-card-count-select\"' in html\nassert \"window.cardStacks['test'].handleCountChange\" in html\nassert 'value=\"auto\"' in html\nassert \"Auto\" in html\nassert \"1 card\" in html\nassert \"3 cards\" in html\nassert \"5 cards\" in html\nassert \"7 cards\" in html\nassert \"9 cards\" in html\n# By default, is_auto_mode=False, so numeric option should be selected\nassert 'value=\"5\" selected' in html\nprint(\"render_card_count_select tests passed!\")\n\nrender_card_count_select tests passed!\n\n\n\n# Test with custom visible_count_options\ncustom_config = CardStackConfig(prefix=\"custom\", visible_count_options=(3, 5, 7))\ncustom_ids = CardStackHtmlIds(prefix=\"custom\")\nselect_el = render_card_count_select(custom_config, custom_ids, current_count=3)\nhtml = to_xml(select_el)\nassert \"1 card\" not in html  # Not in custom options\nassert \"3 cards\" in html\nassert \"9 cards\" not in html  # Not in custom options\nassert \"Auto\" in html  # Auto still present by default\n\n# Test auto_visible_count=False hides Auto option\nno_auto_config = CardStackConfig(prefix=\"noauto\", auto_visible_count=False)\nno_auto_ids = CardStackHtmlIds(prefix=\"noauto\")\nselect_el = render_card_count_select(no_auto_config, no_auto_ids, current_count=3)\nhtml = to_xml(select_el)\nassert 'value=\"auto\"' not in html\nassert \"Auto\" not in html\nprint(\"Custom options test passed!\")\n\n# Test is_auto_mode=True selects Auto option\nselect_auto = render_card_count_select(config, ids, current_count=5, is_auto_mode=True)\nhtml_auto = to_xml(select_auto)\nassert 'value=\"auto\" selected' in html_auto  # Auto should be selected\nassert 'value=\"5\" selected' not in html_auto  # Numeric should NOT be selected\nprint(\"is_auto_mode=True test passed!\")\n\nCustom options test passed!\nis_auto_mode=True test passed!",
    "crumbs": [
      "components",
      "Controls"
    ]
  },
  {
    "objectID": "js/scroll.html",
    "href": "js/scroll.html",
    "title": "JS: Scroll Navigation",
    "section": "",
    "text": "Converts mouse wheel events on the card stack container into navigation button clicks. Uses delta accumulation with a cooldown to handle both trackpads and scroll wheels naturally. Supports mode-based disabling.\n\nsource\n\n\n\ndef generate_scroll_nav_js(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    button_ids:CardStackButtonIds, # Button IDs for navigation triggers\n    disable_in_modes:Tuple=(), # Mode names where scroll nav is suppressed\n)-&gt;str: # JavaScript code fragment for scroll navigation\n\nGenerate JS for scroll wheel to navigation conversion.\n\n# Test scroll nav JS generation\nids = CardStackHtmlIds(prefix=\"cs0\")\nbtn = CardStackButtonIds(prefix=\"cs0\")\njs = generate_scroll_nav_js(ids, btn)\nassert ids.card_stack in js\nassert btn.nav_up in js\nassert btn.nav_down in js\nassert \"isScrollDisabled\" not in js  # No mode check when no modes\nassert \"ns._setupScrollNav\" in js\n\n# Uses event timeStamp for cooldown, not Date.now()\nassert \"evt.timeStamp\" in js\n# assert \"Date.now()\" not in js\n\n# deltaMode normalization\nassert \"deltaMode\" in js\nassert \"DOM_DELTA_LINE\" in js\nassert \"DOM_DELTA_PAGE\" in js\n\n# Trackpad vs mouse wheel detection with separate cooldowns\nassert \"_TRACKPAD_COOLDOWN\" in js\nassert \"_TRACKPAD_DETECT\" in js\nassert \"_NAV_COOLDOWN\" in js\n\n# Discards same-batch events, keeps trackpad events during cooldown\nassert \"Same-batch\" in js\n\n# Uses AbortController for clean listener teardown/re-setup\nassert \"AbortController\" in js\nassert \"_scrollNavAbort\" in js\nassert \"signal\" in js\n\nprint(\"Scroll nav JS basic tests passed!\")\n\nScroll nav JS basic tests passed!\n\n\n\n# Test with disabled modes\njs_modes = generate_scroll_nav_js(ids, btn, disable_in_modes=(\"split\", \"edit\"))\nassert \"isScrollDisabled\" in js_modes\nassert \"'split'\" in js_modes\nassert \"'edit'\" in js_modes\nprint(\"Scroll nav JS mode disabling tests passed!\")\n\nScroll nav JS mode disabling tests passed!",
    "crumbs": [
      "js",
      "JS: Scroll Navigation"
    ]
  },
  {
    "objectID": "js/scroll.html#generate_scroll_nav_js",
    "href": "js/scroll.html#generate_scroll_nav_js",
    "title": "JS: Scroll Navigation",
    "section": "",
    "text": "Converts mouse wheel events on the card stack container into navigation button clicks. Uses delta accumulation with a cooldown to handle both trackpads and scroll wheels naturally. Supports mode-based disabling.\n\nsource\n\n\n\ndef generate_scroll_nav_js(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    button_ids:CardStackButtonIds, # Button IDs for navigation triggers\n    disable_in_modes:Tuple=(), # Mode names where scroll nav is suppressed\n)-&gt;str: # JavaScript code fragment for scroll navigation\n\nGenerate JS for scroll wheel to navigation conversion.\n\n# Test scroll nav JS generation\nids = CardStackHtmlIds(prefix=\"cs0\")\nbtn = CardStackButtonIds(prefix=\"cs0\")\njs = generate_scroll_nav_js(ids, btn)\nassert ids.card_stack in js\nassert btn.nav_up in js\nassert btn.nav_down in js\nassert \"isScrollDisabled\" not in js  # No mode check when no modes\nassert \"ns._setupScrollNav\" in js\n\n# Uses event timeStamp for cooldown, not Date.now()\nassert \"evt.timeStamp\" in js\n# assert \"Date.now()\" not in js\n\n# deltaMode normalization\nassert \"deltaMode\" in js\nassert \"DOM_DELTA_LINE\" in js\nassert \"DOM_DELTA_PAGE\" in js\n\n# Trackpad vs mouse wheel detection with separate cooldowns\nassert \"_TRACKPAD_COOLDOWN\" in js\nassert \"_TRACKPAD_DETECT\" in js\nassert \"_NAV_COOLDOWN\" in js\n\n# Discards same-batch events, keeps trackpad events during cooldown\nassert \"Same-batch\" in js\n\n# Uses AbortController for clean listener teardown/re-setup\nassert \"AbortController\" in js\nassert \"_scrollNavAbort\" in js\nassert \"signal\" in js\n\nprint(\"Scroll nav JS basic tests passed!\")\n\nScroll nav JS basic tests passed!\n\n\n\n# Test with disabled modes\njs_modes = generate_scroll_nav_js(ids, btn, disable_in_modes=(\"split\", \"edit\"))\nassert \"isScrollDisabled\" in js_modes\nassert \"'split'\" in js_modes\nassert \"'edit'\" in js_modes\nprint(\"Scroll nav JS mode disabling tests passed!\")\n\nScroll nav JS mode disabling tests passed!",
    "crumbs": [
      "js",
      "JS: Scroll Navigation"
    ]
  },
  {
    "objectID": "js/touch.html",
    "href": "js/touch.html",
    "title": "JS: Touch Navigation",
    "section": "",
    "text": "Converts touch gestures on the card stack container into navigation button clicks and scale adjustments. Uses the Pointer Events API with setPointerCapture so that events survive HTMX OOB DOM swaps mid-drag.\nSingle-finger gestures:\n\nSimple swipe — a quick flick that doesn’t cover a full card height triggers one navigation step.\nTouch-and-drag — holding the finger down and dragging triggers one step each time the finger travels one focused-slot-height of distance. After direction lock, setPointerCapture pins events to the card stack element so DOM mutations underneath don’t break tracking.\nMomentum — a fast swipe continues navigating after the finger lifts, decelerating via an exponential friction model.\n\nTwo-finger gestures:\n\nPinch-to-zoom — maps to the card stack’s increaseScale / decreaseScale functions.\n\nSupports mode-based disabling via disable_in_modes.\n\nsource\n\n\n\ndef generate_touch_nav_js(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    button_ids:CardStackButtonIds, # Button IDs for navigation triggers\n    disable_in_modes:Tuple=(), # Mode names where touch nav is suppressed\n)-&gt;str: # JavaScript code fragment for touch navigation\n\nGenerate JS for touch gesture to navigation conversion.\n\n# Test touch nav JS generation\nfrom cjm_fasthtml_card_stack.core.html_ids import CardStackHtmlIds\nfrom cjm_fasthtml_card_stack.core.button_ids import CardStackButtonIds\n\nids = CardStackHtmlIds(prefix=\"cs0\")\nbtn = CardStackButtonIds(prefix=\"cs0\")\njs = generate_touch_nav_js(ids, btn)\n\n# Element IDs and button IDs present\nassert ids.card_stack in js\nassert btn.nav_up in js\nassert btn.nav_down in js\n\n# No mode check when no modes specified\nassert \"isTouchDisabled\" not in js\n\n# Setup function exposed on namespace\nassert \"ns._setupTouchNav\" in js\n\n# Pointer Events API (not Touch Events)\nassert \"pointerdown\" in js\nassert \"pointermove\" in js\nassert \"pointerup\" in js\nassert \"pointercancel\" in js\nassert \"pointerType\" in js\nassert \"setPointerCapture\" in js\n\n# Pointer tracking map for multi-touch\nassert \"pointers\" in js\nassert \"primaryId\" in js\n\n# Pinch-to-zoom maps to scale controls\nassert \"ns.increaseScale\" in js\nassert \"ns.decreaseScale\" in js\n\n# Momentum with requestAnimationFrame and friction\nassert \"_TOUCH_MOMENTUM_FRICTION\" in js\nassert \"requestAnimationFrame\" in js\nassert \"momentumTick\" in js\n\n# Direction locking (horizontal vs vertical)\nassert \"deltaX\" in js\n\n# Step distance from focused slot\nassert \"_getTouchStepDistance\" in js\nassert \"viewport-slot\" in js\n\n# Constants inlined\nassert \"_TOUCH_SWIPE_THRESHOLD\" in js\nassert \"_TOUCH_PINCH_THRESHOLD\" in js\nassert \"_TOUCH_VEL_SAMPLES\" in js\n\n# Velocity history buffer\nassert \"history\" in js\n\n# Uses AbortController for clean listener teardown/re-setup\nassert \"AbortController\" in js\nassert \"_touchNavAbort\" in js\nassert \"signal\" in js\n\nprint(\"Touch nav JS basic tests passed!\")\n\nTouch nav JS basic tests passed!\n\n\n\n# Test with disabled modes\njs_modes = generate_touch_nav_js(ids, btn, disable_in_modes=(\"split\", \"edit\"))\nassert \"isTouchDisabled\" in js_modes\nassert \"'split'\" in js_modes\nassert \"'edit'\" in js_modes\n# Momentum loop also checks mode\nassert \"isTouchDisabled\" in js_modes\nprint(\"Touch nav JS mode disabling tests passed!\")\n\nTouch nav JS mode disabling tests passed!",
    "crumbs": [
      "js",
      "JS: Touch Navigation"
    ]
  },
  {
    "objectID": "js/touch.html#generate_touch_nav_js",
    "href": "js/touch.html#generate_touch_nav_js",
    "title": "JS: Touch Navigation",
    "section": "",
    "text": "Converts touch gestures on the card stack container into navigation button clicks and scale adjustments. Uses the Pointer Events API with setPointerCapture so that events survive HTMX OOB DOM swaps mid-drag.\nSingle-finger gestures:\n\nSimple swipe — a quick flick that doesn’t cover a full card height triggers one navigation step.\nTouch-and-drag — holding the finger down and dragging triggers one step each time the finger travels one focused-slot-height of distance. After direction lock, setPointerCapture pins events to the card stack element so DOM mutations underneath don’t break tracking.\nMomentum — a fast swipe continues navigating after the finger lifts, decelerating via an exponential friction model.\n\nTwo-finger gestures:\n\nPinch-to-zoom — maps to the card stack’s increaseScale / decreaseScale functions.\n\nSupports mode-based disabling via disable_in_modes.\n\nsource\n\n\n\ndef generate_touch_nav_js(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    button_ids:CardStackButtonIds, # Button IDs for navigation triggers\n    disable_in_modes:Tuple=(), # Mode names where touch nav is suppressed\n)-&gt;str: # JavaScript code fragment for touch navigation\n\nGenerate JS for touch gesture to navigation conversion.\n\n# Test touch nav JS generation\nfrom cjm_fasthtml_card_stack.core.html_ids import CardStackHtmlIds\nfrom cjm_fasthtml_card_stack.core.button_ids import CardStackButtonIds\n\nids = CardStackHtmlIds(prefix=\"cs0\")\nbtn = CardStackButtonIds(prefix=\"cs0\")\njs = generate_touch_nav_js(ids, btn)\n\n# Element IDs and button IDs present\nassert ids.card_stack in js\nassert btn.nav_up in js\nassert btn.nav_down in js\n\n# No mode check when no modes specified\nassert \"isTouchDisabled\" not in js\n\n# Setup function exposed on namespace\nassert \"ns._setupTouchNav\" in js\n\n# Pointer Events API (not Touch Events)\nassert \"pointerdown\" in js\nassert \"pointermove\" in js\nassert \"pointerup\" in js\nassert \"pointercancel\" in js\nassert \"pointerType\" in js\nassert \"setPointerCapture\" in js\n\n# Pointer tracking map for multi-touch\nassert \"pointers\" in js\nassert \"primaryId\" in js\n\n# Pinch-to-zoom maps to scale controls\nassert \"ns.increaseScale\" in js\nassert \"ns.decreaseScale\" in js\n\n# Momentum with requestAnimationFrame and friction\nassert \"_TOUCH_MOMENTUM_FRICTION\" in js\nassert \"requestAnimationFrame\" in js\nassert \"momentumTick\" in js\n\n# Direction locking (horizontal vs vertical)\nassert \"deltaX\" in js\n\n# Step distance from focused slot\nassert \"_getTouchStepDistance\" in js\nassert \"viewport-slot\" in js\n\n# Constants inlined\nassert \"_TOUCH_SWIPE_THRESHOLD\" in js\nassert \"_TOUCH_PINCH_THRESHOLD\" in js\nassert \"_TOUCH_VEL_SAMPLES\" in js\n\n# Velocity history buffer\nassert \"history\" in js\n\n# Uses AbortController for clean listener teardown/re-setup\nassert \"AbortController\" in js\nassert \"_touchNavAbort\" in js\nassert \"signal\" in js\n\nprint(\"Touch nav JS basic tests passed!\")\n\nTouch nav JS basic tests passed!\n\n\n\n# Test with disabled modes\njs_modes = generate_touch_nav_js(ids, btn, disable_in_modes=(\"split\", \"edit\"))\nassert \"isTouchDisabled\" in js_modes\nassert \"'split'\" in js_modes\nassert \"'edit'\" in js_modes\n# Momentum loop also checks mode\nassert \"isTouchDisabled\" in js_modes\nprint(\"Touch nav JS mode disabling tests passed!\")\n\nTouch nav JS mode disabling tests passed!",
    "crumbs": [
      "js",
      "JS: Touch Navigation"
    ]
  },
  {
    "objectID": "js/viewport.html",
    "href": "js/viewport.html",
    "title": "JS: Viewport Height",
    "section": "",
    "text": "Sets explicit pixel height on the card stack to fill available vertical space.\nAlgorithm: 1. Temporarily collapse card stack to measure natural positions 2. spaceAbove — Visual distance from container top to card stack top (position-based) 3. spaceBelow — Visual distance from card stack bottom to container bottom + space below container 4. viewportHeight = windowHeight - spaceAbove - spaceBelow\nKey design decisions: - Position-based measurement — Measures actual visual positions, not computed margins. Handles margin collapsing, flex gap, grid gap, etc. automatically. - Temporary collapse — Card stack is briefly set to 0px height to measure its natural top position, then restored. - Sibling-agnostic — Doesn’t care about individual siblings; measures aggregate space above and below. - Debug mode — Set window.cardStackDebug = true to log all intermediate values\nThe container_id parameter is the consumer’s parent container that holds the card stack alongside header/footer elements. If not provided, the card stack measures from its own position.\n\nsource\n\n\n\ndef generate_viewport_height_js(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    container_id:str='', # Consumer's parent container ID (empty = use card stack parent)\n)-&gt;str: # JavaScript code fragment for viewport height calculation\n\nGenerate JS for dynamic viewport height calculation.\nUses position-based measurement to determine available space. Temporarily collapses the card stack to measure its natural top position, then calculates available height based on actual visual positions.\nThis approach handles margin collapsing, flex gap, grid gap, and any other CSS layout mechanism automatically.\nDebug mode: Set window.cardStackDebug = true in browser console to log all intermediate calculation values.\n\n# Test that the generator produces valid JS referencing correct IDs\nids = CardStackHtmlIds(prefix=\"cs0\")\njs = generate_viewport_height_js(ids, container_id=\"my-container\")\nassert \"my-container\" in js\nassert ids.card_stack in js\nassert ids.card_stack_inner in js\nassert \"ns.recalculateHeight\" in js\nassert \"calculateAndSetViewportHeight\" in js\n\n# Verify position-based measurement approach\nassert \"spaceAbove\" in js\nassert \"spaceBelow\" in js\nassert \"calculateSpaceBelowCardStack\" in js\n\n# Verify temporary collapse approach for accurate measurement\nassert \"height = '0px'\" in js\nassert \"minHeight = '0px'\" in js\nassert \"offsetHeight\" in js  # Force reflow\n\n# Verify position-based sibling detection (beside vs below)\nassert \"siblingRect.top &lt; currentRect.bottom\" in js\n\n# Verify debug mode\nassert \"window.cardStackDebug\" in js\nassert f\"[{ids.prefix}]\" in js  # debug log prefix\n\n# Verify auto-adjust trigger in resize handler\nassert \"ns.triggerAutoAdjust\" in js\n\n# Verify resize listener uses remove-and-replace (not guard-and-skip)\nhandler_key = f\"_csResizeHandler_{ids.prefix.replace('-', '_')}\"\nassert f\"window.{handler_key}\" in js\nassert \"removeEventListener\" in js\n\nprint(\"Viewport height JS generator tests passed!\")\n\nViewport height JS generator tests passed!\n\n\n\n# Test without container_id (falls back to parent element with null guard)\njs_no_container = generate_viewport_height_js(ids)\nassert \".parentElement\" in js_no_container\n# Verify null guard exists before .parentElement access\nassert \"if (!_csEl) return 400\" in js_no_container\n# Verify position-based measurement is present in both paths\nassert \"spaceAbove\" in js_no_container\nassert \"calculateSpaceBelowCardStack\" in js_no_container\nprint(\"Viewport height JS fallback container test passed!\")\n\nViewport height JS fallback container test passed!",
    "crumbs": [
      "js",
      "JS: Viewport Height"
    ]
  },
  {
    "objectID": "js/viewport.html#generate_viewport_height_js",
    "href": "js/viewport.html#generate_viewport_height_js",
    "title": "JS: Viewport Height",
    "section": "",
    "text": "Sets explicit pixel height on the card stack to fill available vertical space.\nAlgorithm: 1. Temporarily collapse card stack to measure natural positions 2. spaceAbove — Visual distance from container top to card stack top (position-based) 3. spaceBelow — Visual distance from card stack bottom to container bottom + space below container 4. viewportHeight = windowHeight - spaceAbove - spaceBelow\nKey design decisions: - Position-based measurement — Measures actual visual positions, not computed margins. Handles margin collapsing, flex gap, grid gap, etc. automatically. - Temporary collapse — Card stack is briefly set to 0px height to measure its natural top position, then restored. - Sibling-agnostic — Doesn’t care about individual siblings; measures aggregate space above and below. - Debug mode — Set window.cardStackDebug = true to log all intermediate values\nThe container_id parameter is the consumer’s parent container that holds the card stack alongside header/footer elements. If not provided, the card stack measures from its own position.\n\nsource\n\n\n\ndef generate_viewport_height_js(\n    ids:CardStackHtmlIds, # HTML IDs for this card stack instance\n    container_id:str='', # Consumer's parent container ID (empty = use card stack parent)\n)-&gt;str: # JavaScript code fragment for viewport height calculation\n\nGenerate JS for dynamic viewport height calculation.\nUses position-based measurement to determine available space. Temporarily collapses the card stack to measure its natural top position, then calculates available height based on actual visual positions.\nThis approach handles margin collapsing, flex gap, grid gap, and any other CSS layout mechanism automatically.\nDebug mode: Set window.cardStackDebug = true in browser console to log all intermediate calculation values.\n\n# Test that the generator produces valid JS referencing correct IDs\nids = CardStackHtmlIds(prefix=\"cs0\")\njs = generate_viewport_height_js(ids, container_id=\"my-container\")\nassert \"my-container\" in js\nassert ids.card_stack in js\nassert ids.card_stack_inner in js\nassert \"ns.recalculateHeight\" in js\nassert \"calculateAndSetViewportHeight\" in js\n\n# Verify position-based measurement approach\nassert \"spaceAbove\" in js\nassert \"spaceBelow\" in js\nassert \"calculateSpaceBelowCardStack\" in js\n\n# Verify temporary collapse approach for accurate measurement\nassert \"height = '0px'\" in js\nassert \"minHeight = '0px'\" in js\nassert \"offsetHeight\" in js  # Force reflow\n\n# Verify position-based sibling detection (beside vs below)\nassert \"siblingRect.top &lt; currentRect.bottom\" in js\n\n# Verify debug mode\nassert \"window.cardStackDebug\" in js\nassert f\"[{ids.prefix}]\" in js  # debug log prefix\n\n# Verify auto-adjust trigger in resize handler\nassert \"ns.triggerAutoAdjust\" in js\n\n# Verify resize listener uses remove-and-replace (not guard-and-skip)\nhandler_key = f\"_csResizeHandler_{ids.prefix.replace('-', '_')}\"\nassert f\"window.{handler_key}\" in js\nassert \"removeEventListener\" in js\n\nprint(\"Viewport height JS generator tests passed!\")\n\nViewport height JS generator tests passed!\n\n\n\n# Test without container_id (falls back to parent element with null guard)\njs_no_container = generate_viewport_height_js(ids)\nassert \".parentElement\" in js_no_container\n# Verify null guard exists before .parentElement access\nassert \"if (!_csEl) return 400\" in js_no_container\n# Verify position-based measurement is present in both paths\nassert \"spaceAbove\" in js_no_container\nassert \"calculateSpaceBelowCardStack\" in js_no_container\nprint(\"Viewport height JS fallback container test passed!\")\n\nViewport height JS fallback container test passed!",
    "crumbs": [
      "js",
      "JS: Viewport Height"
    ]
  },
  {
    "objectID": "js/controls.html",
    "href": "js/controls.html",
    "title": "JS: Controls",
    "section": "",
    "text": "Syncs the width slider value with localStorage and the card stack inner container’s max-width. Debounces server persistence.\n\n# Test width management JS generation\nids = CardStackHtmlIds(prefix=\"cs0\")\nconfig = CardStackConfig(prefix=\"cs0\")\nurls = CardStackUrls(save_width=\"/cs/save_width\")\n\njs = _generate_width_mgmt_js(ids, config, urls)\nassert \"Width Management\" in js\nassert ids.card_stack_inner in js\nassert ids.width_slider in js\nassert \"ns.updateWidth\" in js\nassert \"ns.decreaseWidth\" in js\nassert \"ns.increaseWidth\" in js\nassert \"ns.applyWidth\" in js\nassert \"ns.triggerAutoAdjust\" in js\nassert urls.save_width in js\nprint(\"Width management JS tests passed!\")\n\nWidth management JS tests passed!",
    "crumbs": [
      "js",
      "JS: Controls"
    ]
  },
  {
    "objectID": "js/controls.html#width-management",
    "href": "js/controls.html#width-management",
    "title": "JS: Controls",
    "section": "",
    "text": "Syncs the width slider value with localStorage and the card stack inner container’s max-width. Debounces server persistence.\n\n# Test width management JS generation\nids = CardStackHtmlIds(prefix=\"cs0\")\nconfig = CardStackConfig(prefix=\"cs0\")\nurls = CardStackUrls(save_width=\"/cs/save_width\")\n\njs = _generate_width_mgmt_js(ids, config, urls)\nassert \"Width Management\" in js\nassert ids.card_stack_inner in js\nassert ids.width_slider in js\nassert \"ns.updateWidth\" in js\nassert \"ns.decreaseWidth\" in js\nassert \"ns.increaseWidth\" in js\nassert \"ns.applyWidth\" in js\nassert \"ns.triggerAutoAdjust\" in js\nassert urls.save_width in js\nprint(\"Width management JS tests passed!\")\n\nWidth management JS tests passed!",
    "crumbs": [
      "js",
      "JS: Controls"
    ]
  },
  {
    "objectID": "js/controls.html#scale-management",
    "href": "js/controls.html#scale-management",
    "title": "JS: Controls",
    "section": "Scale Management",
    "text": "Scale Management\nSyncs the scale slider value with localStorage and a CSS custom property (--card-stack-scale). Debounces server persistence.\n\n# Test scale management JS generation\njs = _generate_scale_mgmt_js(ids, config, urls)\nassert \"Scale Management\" in js\nassert ids.card_stack in js\nassert ids.scale_slider in js\nassert \"ns.updateScale\" in js\nassert \"ns.decreaseScale\" in js\nassert \"ns.increaseScale\" in js\nassert \"ns.applyScale\" in js\nassert \"--card-stack-scale\" in js\nassert \"ns.triggerAutoAdjust\" in js\nprint(\"Scale management JS tests passed!\")\n\nScale management JS tests passed!",
    "crumbs": [
      "js",
      "JS: Controls"
    ]
  },
  {
    "objectID": "js/controls.html#card-count-management",
    "href": "js/controls.html#card-count-management",
    "title": "JS: Controls",
    "section": "Card Count Management",
    "text": "Card Count Management\nManages the visible card count dropdown, localStorage persistence, and the auto/manual mode toggle. Fires HTMX viewport updates when the count changes.\n\n# Test card count management JS generation\nurls_full = CardStackUrls(update_viewport=\"/cs/update_viewport\")\njs = _generate_card_count_mgmt_js(ids, config, urls_full)\nassert \"Card Count Management\" in js\nassert ids.card_stack in js\nassert ids.card_count_select in js\nassert \"ns.updateCardCount\" in js\nassert \"ns._autoUpdateCount\" in js\nassert \"ns.handleCountChange\" in js\nassert \"ns.syncCountDropdown\" in js  # Exposed for external callers\nassert \"_isAutoMode\" in js\nassert \"_syncCountDropdown\" in js\nassert \"_AUTO_KEY\" in js\nassert \"swap: 'none'\" in js\n# Valid count options from config\nassert \"1, 3, 5, 7, 9\" in js\n# is_auto parameter passed in both functions\nassert \"is_auto: 'false'\" in js  # Manual selection\nassert \"is_auto: 'true'\" in js   # Auto-adjustment\nprint(\"Card count management JS tests passed!\")\n\nCard count management JS tests passed!",
    "crumbs": [
      "js",
      "JS: Controls"
    ]
  },
  {
    "objectID": "routes/router.html",
    "href": "routes/router.html",
    "title": "Router",
    "section": "",
    "text": "Factory function that creates an APIRouter with all standard card stack routes wired up. Returns a tuple of (APIRouter, CardStackUrls) so the consumer has access to the route URLs for keyboard navigation and component rendering.\nFor consumers who need custom before/after logic in their handlers (e.g., resetting a caret position before entering split mode), use the Tier 1 response builder functions from routes.handlers directly instead.\n\nsource\n\n\n\ndef init_card_stack_router(\n    config:CardStackConfig, # Card stack configuration\n    state_getter:Callable, # Function to get current state\n    state_setter:Callable, # Function to save state\n    get_items:Callable, # Function to get current items list\n    render_card:Callable, # Card renderer callback: (item, CardRenderContext) -&gt; FT\n    route_prefix:str='/card-stack', # Route prefix for all card stack routes\n    progress_label:str='Item', # Label for progress indicator\n)-&gt;Tuple: # (router, urls) tuple\n\nInitialize an APIRouter with all standard card stack routes.",
    "crumbs": [
      "routes",
      "Router"
    ]
  },
  {
    "objectID": "routes/router.html#init_card_stack_router",
    "href": "routes/router.html#init_card_stack_router",
    "title": "Router",
    "section": "",
    "text": "Factory function that creates an APIRouter with all standard card stack routes wired up. Returns a tuple of (APIRouter, CardStackUrls) so the consumer has access to the route URLs for keyboard navigation and component rendering.\nFor consumers who need custom before/after logic in their handlers (e.g., resetting a caret position before entering split mode), use the Tier 1 response builder functions from routes.handlers directly instead.\n\nsource\n\n\n\ndef init_card_stack_router(\n    config:CardStackConfig, # Card stack configuration\n    state_getter:Callable, # Function to get current state\n    state_setter:Callable, # Function to save state\n    get_items:Callable, # Function to get current items list\n    render_card:Callable, # Card renderer callback: (item, CardRenderContext) -&gt; FT\n    route_prefix:str='/card-stack', # Route prefix for all card stack routes\n    progress_label:str='Item', # Label for progress indicator\n)-&gt;Tuple: # (router, urls) tuple\n\nInitialize an APIRouter with all standard card stack routes.",
    "crumbs": [
      "routes",
      "Router"
    ]
  },
  {
    "objectID": "routes/router.html#tests",
    "href": "routes/router.html#tests",
    "title": "Router",
    "section": "Tests",
    "text": "Tests\n\nfrom cjm_fasthtml_card_stack.core.config import _reset_prefix_counter\nfrom cjm_fasthtml_card_stack.core.models import CardRenderContext\nfrom fasthtml.common import Div, Span\n\n# Simple render_card for testing\ndef _test_render(item, ctx: CardRenderContext):\n    return Div(Span(f\"{item}\"), cls=f\"card-{ctx.card_role}\")\n\n# Simple state storage\n_reset_prefix_counter()\n_state = CardStackState()\n_items = [f\"Test item {i}\" for i in range(10)]\n\ndef _get_state(): return _state\ndef _set_state(s): global _state; _state = s\ndef _get_items(): return _items\n\nprint(\"Test setup ready.\")\n\nTest setup ready.\n\n\n\n# Test router creation and URL generation\n_reset_prefix_counter()\nconfig = CardStackConfig(prefix=\"demo\")\n\nrouter, urls = init_card_stack_router(\n    config=config,\n    state_getter=_get_state,\n    state_setter=_set_state,\n    get_items=_get_items,\n    render_card=_test_render,\n    route_prefix=\"/cs\",\n)\n\nassert router is not None\nassert router.prefix == \"/cs\"\nprint(f\"Router prefix: {router.prefix}\")\n\nRouter prefix: /cs\n\n\n\n# Test URL generation\nassert urls.nav_up == \"/cs/nav_up\"\nassert urls.nav_down == \"/cs/nav_down\"\nassert urls.nav_first == \"/cs/nav_first\"\nassert urls.nav_last == \"/cs/nav_last\"\nassert urls.nav_page_up == \"/cs/nav_page_up\"\nassert urls.nav_page_down == \"/cs/nav_page_down\"\nassert urls.nav_to_index == \"/cs/nav_to_index\"\nassert urls.update_viewport == \"/cs/update_viewport\"\nassert urls.save_width == \"/cs/save_width\"\nassert urls.save_scale == \"/cs/save_scale\"\nprint(\"All URL generation tests passed!\")\nprint(f\"Sample URL: {urls.nav_up}\")\n\nAll URL generation tests passed!\nSample URL: /cs/nav_up\n\n\n\n# Test multi-instance routers produce unique URL prefixes\nconfig_a = CardStackConfig(prefix=\"text\")\nconfig_b = CardStackConfig(prefix=\"vad\")\n\nrouter_a, urls_a = init_card_stack_router(\n    config_a, _get_state, _set_state, _get_items, _test_render,\n    route_prefix=\"/text-stack\",\n)\nrouter_b, urls_b = init_card_stack_router(\n    config_b, _get_state, _set_state, _get_items, _test_render,\n    route_prefix=\"/vad-stack\",\n)\n\nassert urls_a.nav_up == \"/text-stack/nav_up\"\nassert urls_b.nav_up == \"/vad-stack/nav_up\"\nassert urls_a.nav_up != urls_b.nav_up\nprint(\"Multi-instance URL uniqueness tests passed!\")\n\nMulti-instance URL uniqueness tests passed!",
    "crumbs": [
      "routes",
      "Router"
    ]
  },
  {
    "objectID": "core/constants.html",
    "href": "core/constants.html",
    "title": "Constants",
    "section": "",
    "text": "# Test CardRole type\nrole: CardRole = \"focused\"\nassert role == \"focused\"\nrole = \"context\"\nassert role == \"context\"\nprint(\"CardRole type alias tests passed!\")\n\nCardRole type alias tests passed!",
    "crumbs": [
      "core",
      "Constants"
    ]
  },
  {
    "objectID": "core/constants.html#type-aliases",
    "href": "core/constants.html#type-aliases",
    "title": "Constants",
    "section": "",
    "text": "# Test CardRole type\nrole: CardRole = \"focused\"\nassert role == \"focused\"\nrole = \"context\"\nassert role == \"context\"\nprint(\"CardRole type alias tests passed!\")\n\nCardRole type alias tests passed!",
    "crumbs": [
      "core",
      "Constants"
    ]
  },
  {
    "objectID": "core/constants.html#scroll-navigation-constants",
    "href": "core/constants.html#scroll-navigation-constants",
    "title": "Constants",
    "section": "Scroll Navigation Constants",
    "text": "Scroll Navigation Constants\nThresholds for converting mouse wheel events into card navigation.\n\nassert SCROLL_THRESHOLD == 1\nassert NAVIGATION_COOLDOWN == 100\nassert TRACKPAD_COOLDOWN == 250\nprint(\"Scroll constants tests passed!\")\n\nScroll constants tests passed!",
    "crumbs": [
      "core",
      "Constants"
    ]
  },
  {
    "objectID": "core/constants.html#touch-navigation-constants",
    "href": "core/constants.html#touch-navigation-constants",
    "title": "Constants",
    "section": "Touch Navigation Constants",
    "text": "Touch Navigation Constants\nThresholds for converting touch gestures into card navigation and scale adjustments. Touch-and-drag uses the focused slot height as the step distance; these constants govern the simple-swipe fallback, momentum decay after a fast swipe, and pinch-to-zoom sensitivity.\n\nassert TOUCH_SWIPE_THRESHOLD == 30\nassert TOUCH_MOMENTUM_MIN_VELOCITY == 0.5\nassert TOUCH_MOMENTUM_FRICTION == 0.95\nassert TOUCH_PINCH_THRESHOLD == 30\nassert TOUCH_VELOCITY_SAMPLES == 5\nprint(\"Touch constants tests passed!\")\n\nTouch constants tests passed!",
    "crumbs": [
      "core",
      "Constants"
    ]
  },
  {
    "objectID": "core/constants.html#localstorage-key-patterns",
    "href": "core/constants.html#localstorage-key-patterns",
    "title": "Constants",
    "section": "localStorage Key Patterns",
    "text": "localStorage Key Patterns\nKey templates for persisting viewport preferences to localStorage. The prefix is interpolated at runtime to support multi-instance.\n\nsource\n\nauto_count_storage_key\n\ndef auto_count_storage_key(\n    prefix:str, # Card stack instance prefix\n)-&gt;str: # localStorage key for auto card count mode\n\nGenerate localStorage key for auto card count mode.\n\nsource\n\n\ncard_count_storage_key\n\ndef card_count_storage_key(\n    prefix:str, # Card stack instance prefix\n)-&gt;str: # localStorage key for card count\n\nGenerate localStorage key for card count.\n\nsource\n\n\nscale_storage_key\n\ndef scale_storage_key(\n    prefix:str, # Card stack instance prefix\n)-&gt;str: # localStorage key for card scale\n\nGenerate localStorage key for card scale.\n\nsource\n\n\nwidth_storage_key\n\ndef width_storage_key(\n    prefix:str, # Card stack instance prefix\n)-&gt;str: # localStorage key for card width\n\nGenerate localStorage key for card width.\n\n# Test storage key generation\nassert width_storage_key(\"cs0\") == \"cs0-card-width\"\nassert scale_storage_key(\"cs0\") == \"cs0-card-scale\"\nassert card_count_storage_key(\"cs0\") == \"cs0-card-count\"\nassert auto_count_storage_key(\"cs0\") == \"cs0-card-count-auto\"\n\n# Multi-instance keys are unique\nassert width_storage_key(\"text\") != width_storage_key(\"vad\")\nassert auto_count_storage_key(\"text\") != auto_count_storage_key(\"vad\")\nprint(\"Storage key tests passed!\")\n\nStorage key tests passed!",
    "crumbs": [
      "core",
      "Constants"
    ]
  },
  {
    "objectID": "core/constants.html#viewport-defaults",
    "href": "core/constants.html#viewport-defaults",
    "title": "Constants",
    "section": "Viewport Defaults",
    "text": "Viewport Defaults\n\nassert DEFAULT_VISIBLE_COUNT == 3\nassert DEFAULT_CARD_WIDTH == 80\nassert DEFAULT_CARD_SCALE == 100\nprint(\"Viewport default tests passed!\")\n\nViewport default tests passed!",
    "crumbs": [
      "core",
      "Constants"
    ]
  },
  {
    "objectID": "core/config.html",
    "href": "core/config.html",
    "title": "Config",
    "section": "",
    "text": "Auto-generates unique prefixes (cs0, cs1, …) for card stack instances when no explicit prefix is provided. Ensures multi-instance HTML ID uniqueness.\n\n# Test auto-prefix generation\n_reset_prefix_counter()\nassert _auto_prefix() == \"cs0\"\nassert _auto_prefix() == \"cs1\"\nassert _auto_prefix() == \"cs2\"\n_reset_prefix_counter()\nassert _auto_prefix() == \"cs0\"  # Reset works\nprint(\"Prefix counter tests passed!\")\n\nPrefix counter tests passed!",
    "crumbs": [
      "core",
      "Config"
    ]
  },
  {
    "objectID": "core/config.html#prefix-counter",
    "href": "core/config.html#prefix-counter",
    "title": "Config",
    "section": "",
    "text": "Auto-generates unique prefixes (cs0, cs1, …) for card stack instances when no explicit prefix is provided. Ensures multi-instance HTML ID uniqueness.\n\n# Test auto-prefix generation\n_reset_prefix_counter()\nassert _auto_prefix() == \"cs0\"\nassert _auto_prefix() == \"cs1\"\nassert _auto_prefix() == \"cs2\"\n_reset_prefix_counter()\nassert _auto_prefix() == \"cs0\"  # Reset works\nprint(\"Prefix counter tests passed!\")\n\nPrefix counter tests passed!",
    "crumbs": [
      "core",
      "Config"
    ]
  },
  {
    "objectID": "core/config.html#style-defaults",
    "href": "core/config.html#style-defaults",
    "title": "Config",
    "section": "Style Defaults",
    "text": "Style Defaults\nModule-level constants for focused card emphasis. Computed from the cjm_fasthtml_tailwind and cjm_fasthtml_daisyui libraries so consumers can see (and override) the exact default class strings.\n\n# Verify default class strings\nassert _DEFAULT_FOCUS_RING == \"ring-1 ring-[color-mix(in_oklch,var(--color-primary),transparent_50%)]\"\nassert _DEFAULT_FOCUS_SHADOW == \"shadow-lg shadow-primary\"\nassert _DEFAULT_FOCUS_BORDER_RADIUS == \"rounded-box\"\nprint(\"Style default constants tests passed!\")\n\nStyle default constants tests passed!",
    "crumbs": [
      "core",
      "Config"
    ]
  },
  {
    "objectID": "core/config.html#cardstackstyleconfig",
    "href": "core/config.html#cardstackstyleconfig",
    "title": "Config",
    "section": "CardStackStyleConfig",
    "text": "CardStackStyleConfig\nVisual styling for a card stack instance. Spacing values are set as CSS custom properties on the outer container and consumed by child elements via Tailwind’s arbitrary value syntax (e.g., gap-[var(--cs0-section-gap)]). Consumer JS can update them dynamically via style.setProperty().\n\nsource\n\nCardStackStyleConfig\n\ndef CardStackStyleConfig(\n    section_gap:str='1rem', slot_padding:str='0.25rem', viewport_padding_x:str='0.5rem',\n    viewport_padding_y:str='0.5rem', focus_padding_x:str='0.5rem', focus_padding_b:str='1rem',\n    focus_ring:str='ring-1 ring-[color-mix(in_oklch,var(--color-primary),transparent_50%)]',\n    focus_shadow:str='shadow-lg shadow-primary', focus_border_radius:str='rounded-box'\n)-&gt;None:\n\nVisual styling for a card stack instance.\n\n# Test CardStackStyleConfig defaults\nstyle = CardStackStyleConfig()\nassert style.section_gap == \"1rem\"\nassert style.slot_padding == \"0.25rem\"\nassert style.viewport_padding_x == \"0.5rem\"\nassert style.viewport_padding_y == \"0.5rem\"\nassert style.focus_padding_x == \"0.5rem\"\nassert style.focus_padding_b == \"1rem\"\nassert style.focus_shadow == \"shadow-lg shadow-primary\"\nassert style.focus_border_radius == \"rounded-box\"\nprint(\"CardStackStyleConfig defaults tests passed!\")\n\nCardStackStyleConfig defaults tests passed!\n\n\n\n# Test css_vars_style generates correct CSS custom property declarations\nstyle = CardStackStyleConfig()\ncss = style.css_vars_style(\"cs0\")\nassert \"--cs0-section-gap: 1rem\" in css\nassert \"--cs0-slot-padding: 0.25rem\" in css\nassert \"--cs0-viewport-padding-x: 0.5rem\" in css\nassert \"--cs0-viewport-padding-y: 0.5rem\" in css\nassert \"--cs0-focus-padding-x: 0.5rem\" in css\nassert \"--cs0-focus-padding-b: 1rem\" in css\nprint(\"css_vars_style tests passed!\")\n\ncss_vars_style tests passed!\n\n\n\n# Test css_vars_style with custom values and different prefix\nstyle = CardStackStyleConfig(section_gap=\"0.5rem\", slot_padding=\"0.125rem\")\ncss = style.css_vars_style(\"chat\")\nassert \"--chat-section-gap: 0.5rem\" in css\nassert \"--chat-slot-padding: 0.125rem\" in css\n# Unchanged defaults still present\nassert \"--chat-viewport-padding-x: 0.5rem\" in css\nprint(\"css_vars_style custom values test passed!\")\n\ncss_vars_style custom values test passed!",
    "crumbs": [
      "core",
      "Config"
    ]
  },
  {
    "objectID": "core/config.html#cardstackconfig",
    "href": "core/config.html#cardstackconfig",
    "title": "Config",
    "section": "CardStackConfig",
    "text": "CardStackConfig\nInitialization-time settings for a card stack instance. Created once and reused across requests. The prefix drives CardStackHtmlIds and CardStackButtonIds generation for multi-instance support.\n\nsource\n\nCardStackConfig\n\ndef CardStackConfig(\n    prefix:str=&lt;factory&gt;, visible_count_options:Tuple=(1, 3, 5, 7, 9), auto_visible_count:bool=True,\n    card_width_min:int=30, card_width_max:int=120, card_width_step:int=5, card_scale_min:int=50,\n    card_scale_max:int=200, card_scale_step:int=10, click_to_focus:bool=False, disable_scroll_in_modes:Tuple=(),\n    style:CardStackStyleConfig=&lt;factory&gt;\n)-&gt;None:\n\nInitialization-time settings for a card stack instance.\n\n# Test CardStackConfig defaults with auto-prefix\n_reset_prefix_counter()\nconfig1 = CardStackConfig()\nconfig2 = CardStackConfig()\nassert config1.prefix == \"cs0\"\nassert config2.prefix == \"cs1\"\nassert config1.prefix != config2.prefix  # Unique prefixes\nprint(\"Auto-prefix uniqueness tests passed!\")\n\nAuto-prefix uniqueness tests passed!\n\n\n\n# Test CardStackConfig with explicit prefix\nconfig = CardStackConfig(prefix=\"text-stack\")\nassert config.prefix == \"text-stack\"\nprint(\"Explicit prefix test passed!\")\n\nExplicit prefix test passed!\n\n\n\n# Test CardStackConfig field defaults\n_reset_prefix_counter()\nconfig = CardStackConfig()\nassert config.visible_count_options == (1, 3, 5, 7, 9)\nassert config.auto_visible_count == True\nassert config.card_width_min == 30\nassert config.card_width_max == 120\nassert config.card_width_step == 5\nassert config.card_scale_min == 50\nassert config.card_scale_max == 200\nassert config.card_scale_step == 10\nassert config.click_to_focus == False\nassert config.disable_scroll_in_modes == ()\nassert isinstance(config.style, CardStackStyleConfig)\nassert config.style.section_gap == \"1rem\"\nprint(\"CardStackConfig defaults tests passed!\")\n\nCardStackConfig defaults tests passed!\n\n\n\n# Test CardStackConfig with custom values\nconfig = CardStackConfig(\n    prefix=\"chat\",\n    visible_count_options=(3, 5, 7),\n    card_width_min=40,\n    card_width_max=100,\n    card_scale_min=75,\n    card_scale_max=150,\n    click_to_focus=True,\n    disable_scroll_in_modes=(\"split\", \"edit\"),\n    style=CardStackStyleConfig(section_gap=\"0.5rem\", focus_shadow=\"shadow-md\"),\n)\nassert config.prefix == \"chat\"\nassert config.visible_count_options == (3, 5, 7)\nassert config.card_width_min == 40\nassert config.card_scale_min == 75\nassert config.click_to_focus == True\nassert config.disable_scroll_in_modes == (\"split\", \"edit\")\nassert config.style.section_gap == \"0.5rem\"\nassert config.style.focus_shadow == \"shadow-md\"\nassert config.style.slot_padding == \"0.25rem\"  # Unchanged default\nprint(\"CardStackConfig custom value tests passed!\")\n\nCardStackConfig custom value tests passed!",
    "crumbs": [
      "core",
      "Config"
    ]
  },
  {
    "objectID": "core/button_ids.html",
    "href": "core/button_ids.html",
    "title": "Button IDs",
    "section": "",
    "text": "IDs for hidden buttons that the keyboard navigation system triggers via htmx_trigger. These are separate from CardStackHtmlIds because they serve a different purpose: DOM element targeting vs keyboard action triggering.\n\nsource\n\n\n\ndef CardStackButtonIds(\n    prefix:str\n)-&gt;None:\n\nPrefix-based IDs for hidden keyboard action buttons.\n\n# Test CardStackButtonIds\nbtn = CardStackButtonIds(prefix=\"cs0\")\nassert btn.nav_up == \"cs0-btn-nav-up\"\nassert btn.nav_down == \"cs0-btn-nav-down\"\nassert btn.nav_first == \"cs0-btn-nav-first\"\nassert btn.nav_last == \"cs0-btn-nav-last\"\nassert btn.nav_page_up == \"cs0-btn-nav-page-up\"\nassert btn.nav_page_down == \"cs0-btn-nav-page-down\"\nassert btn.width_narrow == \"cs0-btn-width-narrow\"\nassert btn.width_widen == \"cs0-btn-width-widen\"\nassert btn.scale_decrease == \"cs0-btn-scale-decrease\"\nassert btn.scale_increase == \"cs0-btn-scale-increase\"\nprint(\"CardStackButtonIds tests passed!\")\n\nCardStackButtonIds tests passed!\n\n\n\n# Test multi-instance uniqueness\nbtn_a = CardStackButtonIds(prefix=\"text\")\nbtn_b = CardStackButtonIds(prefix=\"vad\")\nassert btn_a.nav_up != btn_b.nav_up\nassert btn_a.nav_up == \"text-btn-nav-up\"\nassert btn_b.nav_up == \"vad-btn-nav-up\"\nprint(\"Button ID multi-instance tests passed!\")\n\nButton ID multi-instance tests passed!",
    "crumbs": [
      "core",
      "Button IDs"
    ]
  },
  {
    "objectID": "core/button_ids.html#cardstackbuttonids",
    "href": "core/button_ids.html#cardstackbuttonids",
    "title": "Button IDs",
    "section": "",
    "text": "IDs for hidden buttons that the keyboard navigation system triggers via htmx_trigger. These are separate from CardStackHtmlIds because they serve a different purpose: DOM element targeting vs keyboard action triggering.\n\nsource\n\n\n\ndef CardStackButtonIds(\n    prefix:str\n)-&gt;None:\n\nPrefix-based IDs for hidden keyboard action buttons.\n\n# Test CardStackButtonIds\nbtn = CardStackButtonIds(prefix=\"cs0\")\nassert btn.nav_up == \"cs0-btn-nav-up\"\nassert btn.nav_down == \"cs0-btn-nav-down\"\nassert btn.nav_first == \"cs0-btn-nav-first\"\nassert btn.nav_last == \"cs0-btn-nav-last\"\nassert btn.nav_page_up == \"cs0-btn-nav-page-up\"\nassert btn.nav_page_down == \"cs0-btn-nav-page-down\"\nassert btn.width_narrow == \"cs0-btn-width-narrow\"\nassert btn.width_widen == \"cs0-btn-width-widen\"\nassert btn.scale_decrease == \"cs0-btn-scale-decrease\"\nassert btn.scale_increase == \"cs0-btn-scale-increase\"\nprint(\"CardStackButtonIds tests passed!\")\n\nCardStackButtonIds tests passed!\n\n\n\n# Test multi-instance uniqueness\nbtn_a = CardStackButtonIds(prefix=\"text\")\nbtn_b = CardStackButtonIds(prefix=\"vad\")\nassert btn_a.nav_up != btn_b.nav_up\nassert btn_a.nav_up == \"text-btn-nav-up\"\nassert btn_b.nav_up == \"vad-btn-nav-up\"\nprint(\"Button ID multi-instance tests passed!\")\n\nButton ID multi-instance tests passed!",
    "crumbs": [
      "core",
      "Button IDs"
    ]
  }
]